---
aliases: 1-2-承诺机制
tags:
date created: Wednesday, March 19th 2025, 8:18:02 pm
date modified: Wednesday, March 19th 2025, 8:18:33 pm
---
# 承诺方案
这段话的核心内容是**基于哈希函数的承诺方案（commitment scheme）及其安全性分析**，以及**哈希函数的 "puzzle-friendly" 性质**。我们可以逐步拆解它的逻辑：
### 1. **承诺（Commitment）的实现**
承诺方案的目的是让某人提交一个值（message）但在揭示之前保持其隐藏，同时保证一旦提交就无法更改。
- **提交阶段（Commitment）**：
    1. 生成一个**随机的 256 位密钥** kk。
    2. 计算 $\text{commitment} = H(k \| \text{msg})$ （哈希密钥和消息的拼接）。
    3. 公开 $\text{commitment}$，但不公开 kk。
    4. 仅公开 $H(k)$（即密钥的哈希值），确保 kk 之后可以被验证但不会被伪造。
- **验证阶段（Verification）**：
    1. 当需要验证时，提交者公开 $k$ 和 $\text{msg}$。
    2. 验证者计算 H(k∥msg)H(k \| \text{msg}) 并检查是否等于之前看到的 commitment。
    3. 如果匹配，则验证通过，否则失败。
---
### 2. **承诺方案的安全性**
这个承诺方案依赖于哈希函数的两大安全性质：
#### （1）**隐藏性（Hiding）**
目标：**在不知道 kk 的情况下，无法推测出 msg\text{msg}**。
- 由于 kk 是随机的 256 位数，从一个**分布非常均匀的范围**中选取，这会使得 H(k∥msg)H(k \| \text{msg}) 结果也随机分布。
- 因此，**即使攻击者知道 commitment，也无法恢复出 msg**，这正是承诺方案所需的隐藏性。
#### （2）**绑定性（Binding）**
目标：**提交后无法更改 msg**。
- 假设攻击者试图找到两个不同的消息 $\text{msg}_1$ 和 $\text{msg}_2$，使得： $H(k \| \text{msg}_1) = H(k \| \text{msg}_2)$
- 这相当于找到哈希碰撞（collision），而**哈希函数是抗碰撞的（collision-resistant）**，因此攻击者几乎不可能成功。
- 这保证了提交者无法在之后更改 msg。
---
### 3. **Puzzle-Friendly 性质**
这是哈希函数的第三个安全性质，主要用于构造**工作量证明（Proof-of-Work）**类问题，例如比特币挖矿。
- **定义**：如果哈希函数 $H(k,x)$ 具有 "puzzle-friendly" 属性，则当 $k$ 来自高熵分布（即均匀随机选择）时，对于给定的目标值 $y$，几乎无法找到 $x$ 使得： $H(k, x) = y$
- **直观理解**：
    - 假设攻击者希望找到某个 $x$，使得哈希值恰好落入某个目标集合 $Y$。
    - 由于 $k$ 是高熵的随机值，哈希函数的输出几乎是随机的，因此唯一找到 $x$ 的方法是**穷举搜索（brute-force search）**，没有捷径可走。
#### **应用：搜索难题（Search Puzzle）**
这种性质可以用于构造**计算难题**：
- 设定一个 **puzzle ID**，这个 ID 也是一个随机数。
- 目标是找到某个解 $x$，使得： $H(\text{ID}, x) \in Y$
- 由于 ID 是高熵的，唯一的解法是暴力搜索 $x$，没有优化算法可用。
这种机制在**工作量证明（Proof-of-Work）**系统（如比特币）中非常重要。
---
### 4. **总结**
- **承诺方案**利用哈希函数的 **隐藏性（Hiding）** 和 **抗碰撞性（Collision-resistant）** 确保安全性。
- **Puzzle-Friendly** 性质确保某些计算问题只能通过暴力搜索解决，从而可以用于**构造工作量证明（Proof-of-Work）** 类应用，如区块链挖矿。
---
# 为什么公开 $H(k)$?
是的，你的理解已经很清楚了！你准确地抓住了**承诺方案（Commitment Scheme）**的核心逻辑：

1. **单独哈希 msg 不安全**
    - 如果直接使用 $H(\text{msg})$ 作为承诺，攻击者可以通过暴力搜索猜出可能的 $msg$（如果 $msg$ 的可能值较少）。
2. **引入随机数 kk 提高安全性**
    - 通过计算 $H(k \| \text{msg})$ 并公开这个哈希值，使得攻击者无法通过暴力搜索推导出 msg（因为 kk 取值范围很大，搜索成本极高）。
3. **防止伪造（Binding）**
    - 仅仅提交 $H(k \| \text{msg})$ 还不够，因为提交者可能伪造不同的 $k'$ 和 $\text{msg}'$，找到另一个满足相同哈希值的组合。
    - 解决方案：同时公开 $H(k)$，让验证者在揭示阶段确认提交者提供的 $k$ 确实是最初承诺的 $k$（确保 $k$ 没有被篡改）。
4. **最终验证**
    - 揭示阶段，提交者公布 $k$ 和 $\text{msg}$。
    - 验证者检查：
        1. $H(k)$ 是否与最初公开的哈希匹配？（防止 $k$ 被篡改）
        2. $H(k \| \text{msg})$ 是否与承诺的哈希匹配？（确保 $msg$ 也没被篡改）

### **核心安全性总结**

- **Hiding（隐藏性）**：攻击者无法通过 $H(k \| \text{msg})$ 反推出 $msg$，因为 $k$ 取值范围足够大，使得暴力搜索不可行。
- **Binding（绑定性）**：提交者无法在事后更改 $msg$，因为 $k$ 也被哈希锁定了，防止伪造其他可能的 $k' \| \text{msg}'$。

你的总结完全正确，承诺方案的关键点就是**在保护 msg 隐私的同时，又保证提交者不能事后更改 msg**，这一点在**区块链、数字签名、零知识证明**等密码学应用中非常重要。