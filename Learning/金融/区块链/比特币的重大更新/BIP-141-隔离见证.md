# BIP-141：隔离见证（Segregated Witness，SegWit）
**BIP-141** 是比特币的一个重大协议更新，正式提出 **隔离见证（Segregated Witness, SegWit）**，旨在 **解决交易可塑性**，同时 **提高比特币的区块容量**。
- **提案编号**：BIP-141
- **提出者**：Pieter Wuille
- **激活时间**：2017 年 8 月 23 日（软分叉）
- **主要目标**：
    1. 解决**交易可塑性（Transaction Malleability）**问题。
    2. 提高比特币区块的实际**吞吐量（block throughput）**。
    3. 让比特币未来更容易进行**二层扩展**（如闪电网络）。
---
## **1. 为什么需要 BIP-141？**
在比特币原始交易结构中，每个交易都会包含：
- **输入（Input）**：包含上一笔交易的输出（UTXO），以及 **解锁脚本（Unlocking Script，SigScript）**，其中包括 **签名和公钥**。
- **输出（Output）**：指定比特币的接收地址和金额。
问题出现在 **输入部分**：
1. **交易可塑性**
    - 比特币的交易 ID（`txid`）是整个交易内容的 **哈希值**。
    - 由于**解锁脚本（SigScript）中包含签名**，攻击者可以**稍微修改签名**，不影响交易的有效性，却能改变交易的 `txid`。
    - 这样会导致依赖该 `txid` 的交易失效，从而影响支付通道（如闪电网络）。
2. **区块容量限制**
    - 比特币的区块大小被限制为 **1MB**。
    - 由于每笔交易的 **解锁脚本（SigScript）** 可能很长（包含签名），这部分数据占用了大量空间，降低了**每个区块能容纳的交易数**。
---
## **2. BIP-141 具体做了哪些改变？**
BIP-141 **引入了“隔离见证”机制**，核心思想是 **把交易签名数据（见证数据，witness）从交易的主要数据结构中分离出去**。
### **📌 主要更新点**
1. **把见证数据（Witness Data）从原始交易数据中隔离**
    - 交易的 `txid` **不再包含签名数据**，这样即使签名被改变，`txid` 仍然保持不变，从而**消除了交易可塑性**。
2. **引入“见证结构”**
    - **原始的交易结构**：
        ```text
        [input] [unlocking script（签名 + 公钥）] [output]
        ```
    - **BIP-141 后的交易结构**：
        ```text
        [input] [output] [witness data（签名 + 公钥）]
        ```
    - 这样，交易的 `txid` 只计算 **[input] + [output]**，而**见证数据不影响 `txid`**。
3. **改变区块大小的计算方式**
    - 传统比特币的区块大小**上限 1MB**。
    - BIP-141 **引入了“权重（Weight）”概念**：
        - **区块权重 = 交易的非见证数据大小 × 3 + 见证数据大小 × 1**。
        - **最大区块权重 = 4,000,000（相当于 4MB）**，但大部分区块的实际数据仍然低于 2MB。
---
## **3. SegWit 交易结构（P2WPKH 示例）**
BIP-141 定义了一种新的交易格式，例如：
### **普通的 P2PKH 交易（旧格式）**
```text
Input:
    [Signature + Public Key]  ⬅ 解锁脚本（SigScript）
Output:
    [OP_DUP OP_HASH160 <PubKeyHash> OP_EQUALVERIFY OP_CHECKSIG]
```
### **SegWit 交易（P2WPKH）**
```text
Input:
    [Empty]  ⬅ SegWit 交易的 input 没有解锁脚本
Output:
    [OP_0 <PubKeyHash>]  ⬅ 只包含公钥哈希
Witness:
    [Signature]
    [Public Key]
```
> 见证数据被“隔离”到 `Witness` 部分，而不是 `Input`。
---
## **4. BIP-141 带来的改进**
✅ **解决交易可塑性**
- 因为 `txid` 计算时 **不包含见证数据**，所以攻击者无法篡改签名来改变 `txid`。
✅ **提高比特币区块容量**
- 由于见证数据的存储方式不同，比特币**实际可容纳的交易量变多**，等效提升区块大小至 **2MB ~ 4MB**。
✅ **为闪电网络等二层扩展铺路**
- **闪电网络（Lightning Network）** 依赖于 `txid` 的不可篡改性，SegWit 让它变得可行。
✅ **降低手续费**
- SegWit 交易的见证数据权重较低，实际 **交易费用减少**。
---
## **5. BIP-141 激活过程**
BIP-141 采用 **BIP-9 机制** 进行软分叉：
- 2017 年 7 月 21 日，**SegWit 的支持率达到 95%**，矿工开始执行 BIP-141 规则。
- 2017 年 8 月 23 日，SegWit **正式激活**。
---
## **6. 兼容性问题**
**Q：旧版比特币客户端是否支持 SegWit？**
- **是的！**SegWit 采用 **软分叉**，旧客户端仍然可以处理 SegWit 交易，但不会验证 `Witness` 部分的数据。
**Q：普通地址和 SegWit 地址有什么区别？**
- 旧地址（P2PKH）：`1xxxxxxx`
- SegWit 地址（P2WPKH）：`bc1xxxxxx`
---
## **7. 代码示例**
### **使用 Python 创建 SegWit 交易**
```python
from bitcoin.core import CMutableTransaction, CMutableTxIn, CMutableTxOut
from bitcoin.wallet import P2WPKHBitcoinAddress
from bitcoin.core.script import OP_0
# 创建 SegWit 地址
segwit_address = P2WPKHBitcoinAddress('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kdh0f4')
# 创建交易
txin = CMutableTxIn(…)  # 输入
txout = CMutableTxOut(amount, segwit_address.to_scriptPubKey())  # 输出
# 创建交易对象
tx = CMutableTransaction([txin], [txout])
print(tx)
```
---
## **8. 总结**
|**BIP-141 主要内容**|**解释**|
|---|---|
|**激活时间**|2017 年 8 月 23 日|
|**主要作用**|解决交易可塑性、提高区块吞吐量|
|**引入“见证”结构**|把签名数据从 `input` 中隔离|
|**新的交易格式**|`P2WPKH`, `P2WSH`|
|**改变区块计算方式**|引入“权重（Weight）”概念|
|**影响**|让闪电网络、Schnorr 签名等扩展更容易实现|
# 权重和验证
你的问题非常深刻，涉及交易可塑性、区块权重计算和 SegWit 交易的验证过程。我们来深入解析：
## **1. 交易可塑性问题的本质**
你的理解**部分正确**，但有些地方需要澄清。
### **🔍 交易可塑性 (Transaction Malleability) 现象**
比特币交易的 `txid` 计算方式：
```python
txid = SHA256(SHA256(serialized_tx))
```
其中，交易的序列化数据 `serialized_tx` **包含了解锁脚本（scriptSig）**，而 `scriptSig` 包含了**签名**。
**问题**：
- ==由于**签名本身的格式允许多种合法表达方式**(也就是一个签名可以有多种表示方式)==，攻击者可以**修改签名的表示方式**（如 DER 编码的细微变更）**但不改变签名的有效性**。
- 这种情况下，交易仍然有效 **(签名仍然正确，交易可以被接受)**，但其 `txid` 发生变化。
- 这导致 **依赖于该 `txid` 的交易（如二次支付）会变得无效**，因为它们引用的 `txid` 发生了变化。
### **🔴 交易可塑性的影响**
1. **二次支付 (Double Spend)**
    - 假设 Alice 发送 1 BTC 给 Bob，Bob 看到交易广播后，立刻发起一个新交易，将这 1 BTC 进一步转发给 Carol。
    - **攻击者修改了 Alice → Bob 交易的 `txid`**，但交易内容仍然有效。
    - 这样，Bob 生成的交易（`txid1`）就失效了，因为它引用的是原 `txid`，但现在 `txid` 变成 `txid2`。
    - Bob 可能会**重复发起新的交易**，导致意外的支付。
2. **支付通道的影响（闪电网络）**
    - 闪电网络的原理是通过**未上链的交易**构建支付通道，最终结算到链上。
    - 如果交易 `txid` 可变，那么支付通道的可靠性就无法保证，影响比特币的可扩展性。
### **🔵 SegWit 如何解决？**
SegWit **改变了 `txid` 的计算方式**：
- 见证数据（witness）**不再包含在 `txid` 计算中**。
- 这样，即使攻击者修改了签名格式，`txid` 仍然保持不变，从而完全消除了交易可塑性问题。
---
## **2. 区块权重 (Weight) 及其作用**
你对**“权重计算公式像是平白无故增大了交易大小”**的疑问是合理的，关键是 **权重（Weight）** 并不等同于区块大小。
### **🔍 传统区块大小限制**
- **原比特币区块大小 = 1MB**
- 这个限制使得**比特币的吞吐量受到很大限制**（最多 7 TPS）
### **🔵 SegWit 如何调整区块大小？**
**引入新的“权重”计算方式**：
```text
区块权重 = 交易的非见证数据大小 × 3 + 见证数据大小 × 1
```
- **非见证数据**（`input` 和 `output`）：原本的交易数据部分
- **见证数据**（签名数据）：被隔离到 `witness` 部分
**解释：**
- 由于 `witness` 数据本质上是**辅助数据**，并不影响 `txid`，所以它的权重 **仅按 1 倍计算**。
- 而非见证数据是**必须存储的交易数据**，所以仍然按 **3 倍计算**。
- 这样，**整体上区块的实际大小变大了，但有效数据占比也提高了**。
### **🔴 计算示例**
假设一笔交易：
- **非见证数据**：250 字节
- **见证数据**：100 字节
按照旧的区块大小计算：
```text
总交易大小 = 250 + 100 = 350 字节
```
按照 SegWit 的权重计算：
```text
区块权重 = (250 × 3) + (100 × 1) = 850
```
**最大区块权重 = 4,000,000（相当于 4MB）**，但大部分区块的实际数据仍然低于 2MB。
这样，比特币网络的**实际吞吐量提高了 2 倍左右**，但仍然兼容原来的 1MB 限制。
## **3. SegWit 交易的验证过程**
SegWit 交易的验证方式与传统 P2PKH 交易有所不同，主要是 **见证数据的使用**。
### **🔍 P2PKH 交易验证**
**示例**
```text
锁定脚本（Locking Script）:
    OP_DUP OP_HASH160 <PubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
解锁脚本（Unlocking Script）:
    <Signature> <Public Key>
```
验证步骤：
1. **将 `unlocking script` 入栈**
    ```text
    [Signature] [Public Key]
    ```
2. **执行 `locking script`**
    - `OP_DUP` 复制公钥：
        ```text
        [Signature] [Public Key] [Public Key]
        ```
    - `OP_HASH160` 计算公钥哈希：
        ```text
        [Signature] [Public Key] [PubKeyHash]
        ```
    - `OP_EQUALVERIFY` 确保哈希匹配
    - `OP_CHECKSIG` 检查 `Signature` 是否有效
---
### **🔵 SegWit 交易的验证**
SegWit 交易中，**解锁脚本（`scriptSig`）是空的**，签名数据被放在 **见证数据（Witness）** 里。
**P2WPKH 示例**
```text
锁定脚本（scriptPubKey）:
    OP_0 <PubKeyHash>
见证数据（Witness）:
    [Signature]
    [Public Key]
```
#### **验证过程**
1. **从 witness 读取签名数据**
    ```text
    [Signature] [Public Key]
    ```
2. **计算 `scriptPubKey` 的哈希**
    - `OP_0` 表示 P2WPKH。
    - `PubKeyHash` 提供了目标公钥的哈希值。
3. **使用 `Public Key` 计算哈希并匹配 `PubKeyHash`**
4. **验证签名**
    - 使用 `Public Key` 验证 `Signature` 是否正确
> **注意**：见证数据在 `txid` 计算时不会被包括，避免交易可塑性问题。
---
## **总结**
### **1. 交易可塑性**
- 交易可塑性问题的本质是 **`txid` 依赖 `scriptSig`，而 `scriptSig` 可被修改**。
- SegWit 通过 **移除 `scriptSig`，只在见证数据（`Witness`）中存储签名**，从而解决了这个问题。
### **2. 区块权重**
- SegWit 并没有直接提高 1MB 限制，而是使用**权重**：
    - **区块权重 = 非见证数据 × 3 + 见证数据 × 1**
- 这样，**交易的核心数据占比变高，提升了吞吐量**。
### **3. SegWit 交易验证**
- 传统 P2PKH 交易的 `scriptSig` 直接参与验证。
- SegWit 交易的 `scriptSig` 为空，改用 `Witness` 数据验证。
---
# 终极通俗版解读：SegWit如何用“数据称重法”突破1MB限制
#### **1. 比特币区块 = 一辆限重卡车**
- **原始规则（2017年前）**：卡车货厢容量固定为 **1MB**，所有货物（交易数据）必须塞进这个车厢。
- **核心问题**：
    - 60%的货物是“泡沫填充物”（签名数据），实际有效货物（转账信息）仅占40%。
    - 车厢塞满后，运费（手续费）暴涨，用户抱怨效率低下。
---
#### **2. SegWit的智慧：重新定义“货物价值”**
SegWit发明了 **“数据称重计价法”**，将货物分为两类：

| **货物类型** | **重量系数** | **实际内容**         | **举例（1笔交易）**       |
| -------- | -------- | ---------------- | ------------------ |
| **黄金货物** | ×3       | 核心交易数据（谁转给谁，多少钱） | 占0.25KB，但按0.75KB计重 |
| **泡沫货物** | ×1       | 签名数据（安全校验信息）     | 占0.6KB，按0.6KB计重    |
**新规则**：卡车总载重上限从 **1MB** 改为 **400万权重单位**（等效1.7MB）。
- **计算公式**：`总权重 = 黄金货物×3 + 泡沫货物×1 ≤ 400万`
- **实际效果**：
    - 若装满黄金货物：400万 ÷ 3 ≈ 1.33MB（比旧卡车多装33%）
    - 若混装黄金+泡沫：最高可等效扩容至 **1.7MB**（提升70%）
---
#### **3. 现实案例：一笔交易的扩容收益**
假设某区块包含：
- **黄金货物**：800KB（核心转账数据） → 权重 = 800×3 = 240万
- **泡沫货物**：900KB（签名数据） → 权重 = 900×1 = 90万
- **总权重**：240 + 90 = 330万 < 400万 → **未超载，仍可继续装货**
此时实际数据体积 = 800 + 900 = 1.7MB，但旧节点只看到800KB（黄金货物），误以为未超1MB限制。
---
#### **4. 为何说这是“间接扩容”？**
- **对旧节点（未升级者）**：  
    它们仍认为卡车容量是1MB，仅检查黄金货物是否超1MB，忽略泡沫货物。
- **对新节点（升级者）**：  
    能识别总权重，实际享受1.7MB容量，处理更多交易。
**结果**：
- 兼容性：新旧系统和平共存
- 扩容性：实际交易处理量提升（如从每秒7笔→12笔）
---
#### **5. 用户收益：手续费降低70%**
假设扩容前：1MB区块处理2000笔交易，每笔手续费中位数5美元  
扩容后：1.7MB区块处理3400笔交易，手续费中位数降至 **1.5美元**（供需关系改善）。
这种设计为后续 **闪电网络**（超高速小额支付）铺平了道路，成为比特币史上的关键转折点