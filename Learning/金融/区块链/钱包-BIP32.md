# 分层确定性钱包
好，咱们开始详细学习 **BIP32** ——也就是**分层确定性钱包（HD Wallet）** 的基础！
我会分成几个层次讲，既让你细节懂清楚，也让你整体结构有把握。
# 1. 🔹 为什么需要BIP32？
在**线性确定性钱包**的问题中，我们说了：
- 地址不能分类管理
- 备份麻烦
- 多账户混乱
- 钱包恢复困难
所以，**BIP32（HD Wallet）** 提出了一个改进办法：
> 用一棵**树状结构**来生成地址！  
> 每个节点可以无限分叉，分得清清楚楚。
✅ 分账户  
✅ 分用途  
✅ 方便恢复  
✅ 更安全灵活
# 2. 🔹 BIP32的设计核心
**关键词**：
- **种子（Seed）**
- **主私钥（Master Private Key）**
- **主链码（Master Chain Code）**
- **子私钥 / 子公钥（Child Keys）**
- **分层路径（Path）**
---
# 3. 🔹 最顶层：种子 ➔ 主密钥对
一开始，有一个随机数种子（比如128位、256位）。
种子通过 **HMAC-SHA512** 运算，生成两个东西：
| 结果        | 内容                           |
| --------- | ---------------------------- |
| 左半部分 256位 | 变成**主私钥 Master Private Key** |
| 右半部分 256位 | 变成**主链码 Master Chain Code**  |
> 链码（Chain Code）很重要！它是推导子密钥时用的，不是私钥本身！
✅ 主私钥 + 主链码 ➔ 决定整个钱包。
只要保存这两个，整个钱包都能恢复！
# 4. 🔹 分层推导：派生子密钥（Child Key Derivation）
主密钥可以推导出**子密钥**，  
子密钥又可以推导出**孙密钥**，  
形成一个**树**：
```
m (主密钥)
├── 0 (第一个账户)
│   ├── 0 (收款地址1)
│   ├── 1 (收款地址2)
│   └── …
└── 1 (第二个账户)
    ├── 0 (收款地址1)
    └── …
```
每个分支有一个**编号（Index）**。编号是一个32位整数。
**每一层推导密钥的算法都是**：
- 输入：父公钥 / 父私钥 + 父链码
- 加上子编号（index）
- 再做 HMAC-SHA512 运算
- 结果一半变成新私钥，另一半变成新链码
---
# 5. 🔹 普通子密钥 和 硬化子密钥
这里很重要！！
在BIP32里，子密钥分两种：

| 类型                    | 特点                   |
| --------------------- | -------------------- |
| 普通子密钥（Normal Child）   | 可以用父**公钥**推导出！       |
| 硬化子密钥（Hardened Child） | 只能用父**私钥**推导，公钥推导不了！ |
为什么要有这两种？
- 如果别人拿到父公钥（比如你给了收款地址），
- 他就能推导出所有普通子公钥！
- 但推导不了**硬化子公钥**，增加安全性！
> 硬化（Hardened）通过子编号加上2³¹来标记。 （比如：index = 0x80000000 以上的是硬化节点）
# 6. 🔹 分层路径表示法（Path）
BIP32定义了一种简洁表示路径的方法，比如：
```
m / 0' / 0 / 5
```
意思是：
- 从主私钥 `m` 开始
- 第0号子节点（硬化的，加'号）
- 再第0号子节点
- 再第5号子节点
**`'`号表示硬化（hardened）**！
例如：
```
m / 44' / 0' / 0' / 0 / 5
```
是一个常见的路径（符合 BIP44 标准）。
# 7. 🔹 举个完整的推导例子
假设我们有：
- 种子 ➔ 主私钥 `k_master` 和主链码 `c_master`
- 现在推导第一个子地址：
推导过程：
1. 拼接数据：
    - 如果是普通子密钥：用父公钥 + 子编号
    - 如果是硬化子密钥：用父私钥 + 子编号
2. 做 HMAC-SHA512（以链码为Key）
3. 得到512位：
    - 左半部分：当成一个整数，加到父私钥上，得到子私钥
    - 右半部分：新的子链码
🔹 数学公式（普通子密钥）：
```
k_child = (k_parent + IL) mod n
c_child = IR
```
其中，`IL` 是 HMAC 左半部分。
（如果是硬化子密钥，步骤稍有不同，需要私钥参与）
# 8. 🔹 小结：BIP32核心总结
|概念|说明|
|---|---|
|种子（Seed）|随机数，用来生成主私钥和主链码|
|主私钥 / 主链码|整个钱包的根|
|子私钥|通过链码 + 密钥推导出新的密钥|
|硬化推导|保护钱包安全，防止泄露子公钥攻击|
|分层路径|`m/0'/1/2'` 这种表示法，分清账户与地址|
|HMAC-SHA512|推导子密钥的核心密码算法|
要不要我接下来给你**画一张图**？  
把整个 **种子 ➔ 主私钥 ➔ 子私钥 ➔ 地址** 的流程清晰画出来？🌟
要的话告诉我！  
我还可以继续讲讲 BIP32 **公钥推导机制** 和 **钱包备份恢复**，非常有趣！
# 助记词 (BIP 39)
明白了，你想继续深入到 **BIP39（助记词）**，那我接着给你详细讲！
咱们像刚才一样，从**背景、原理、细节**一层一层讲，帮你真正吃透。
# 1. 🔹 为什么需要BIP39？
前面我们说，**BIP32** 钱包虽然牛，但是：
- 它的种子是个随机数（比如 128 位或 256 位）。
- 随机数本身很难保存，手动抄写几乎不可能，太容易错了！
如果你直接记种子（随机数），根本做不到安全、方便地备份。
所以，**BIP39** 提出了一个办法：
> **用一组简单的单词（助记词）来表示种子！**

✅ 好记  
✅ 好抄  
✅ 人类友好  
✅ 不降低安全性
# 2. 🔹 BIP39的设计思路
助记词是怎么来的？  
**核心流程是这样**：
**（1）生成随机熵（Entropy）**
先随机生成 128 ~ 256 位的二进制熵（entropy），比如：

| 熵位数  | 助记词个数 |
| ---- | ----- |
| 128位 | 12个词  |
| 160位 | 15个词  |
| 192位 | 18个词  |
| 224位 | 21个词  |
| 256位 | 24个词  |
**（2）计算校验位**
用 SHA256 对熵做一次哈希，取前几位作为校验位，防止助记词出错。
校验位长度 = 熵长度 ÷ 32
举例：
- 128 位熵 ➔ 校验 4 位
- 256 位熵 ➔ 校验 8 位
**（3）连接熵 + 校验位**
变成一串更长的比特串（原熵 + 校验位）。
**（4）每11位一组，映射成单词**
- BIP39标准词表有**2048个单词**。
- 2¹¹ = 2048，所以11位二进制正好映射一个单词！
比如，  
`10101000110` ➔ 第 1366 个单词（比如 "photo"）
这样，一长串随机数，就变成了**12、15、18、21、24个常见英文单词**！
# 3. 🔹 助记词 ➔ 种子
**助记词本身并不是种子！**  
助记词需要通过一个过程再变成最终的种子。
**过程：**
助记词经过 **PBKDF2-HMAC-SHA512** 加密计算，生成一个512位（64字节）的种子。
- 输入：助记词（Mnemonic）+ 可选的密码短语（passphrase）
- 算法：PBKDF2（2048次迭代，HMAC-SHA512）
```
seed = PBKDF2(mnemonic, salt="mnemonic" + passphrase, 2048 rounds)
```
最终得到的这个种子，就是**BIP32**主私钥生成的输入！
✅ 助记词 ➔ 种子 ➔ 主私钥 + 主链码 ➔ 整棵钱包树！
# 4. 🔹 总结流程图
一张大图让你快速理解整体：
![[Pasted image 20250408185805.png]]
```
随机熵 (128~256 bits)
     ↓
加校验位
     ↓
每11位对应一个单词
     ↓
助记词（12/15/18/21/24个词）
     ↓
PBKDF2(HMAC-SHA512, 2048次)
     ↓
种子 (512 bits)
     ↓
BIP32: 生成主私钥 + 主链码
     ↓
生成整个分层确定性钱包
```
---
# 5. 🔹 小知识：BIP39助记词词表
- 英文版 2048 个单词，设计得很细心：
    - 单词都比较常见
    - 发音清晰，减少抄错
    - 每个单词前4个字母都能唯一确定
- 也有日文版、中文繁体版、西班牙语版等，不同语言都有助记词表。
---
# 6. 🔹 例子
假设熵是（128位）：
```
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
```
加上校验位后，得到132位比特串。
每11位一组，分成12组，分别映射到单词：
比如：`abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about`
（这个例子是有名的，测试用助记词）
# 7. 🔹 小结一波
|概念|说明|
|---|---|
|随机熵|随机生成的原始比特流|
|校验位|用于检查助记词是否正确|
|助记词|一组单词表示熵 + 校验位|
|种子（Seed）|从助记词推导出来的，用来生成钱包|
|钱包|种子 ➔ BIP32 ➔ 整棵地址树|

要不要我接着再带你做一遍**完整实例演练**？  
比如：随机生成熵 ➔ 生成助记词 ➔ 转种子 ➔ 生成主密钥 ➔ 推导一个地址！🔍  
（这样你自己也能推一遍，超有成就感！）要不要？