# 查询使用者： w, who, last, lastlog
如何查询一个用户的相关数据呢？这还不简单，我们之前就提过了 id, finger 等指令了，都可以让您了解到一个用户的相关信息啦！那么想要知道使用者到底啥时候登入呢？ 最简单可以使用 `last` 检查啊！这个玩意儿我们也在 第十章 bash 提过了， 您可以自行前往参考啊！简单的很。
那如果你想要知道目前已登入在系统上面的用户呢？可以透过 w 或 who 来查询喔！如下范例所示：
```shell
[root@study ~]# w
01:49:18 up 25 days, 3:34, 3 users, load average: 0.00, 0.01, 0.05
USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT
dmtsai tty2 07Jul15 12days 0.03s 0.03s -bash
dmtsai pts/0 172.16.200.254 00:18 6.00s 0.31s 0.11s sshd: dmtsai [priv]
# 第一行显示目前的时间、开机 (up) 多久，几个用户在系统上平均负载等；
# 第二行只是各个项目的说明，
# 第三行以后，每行代表一个使用者。如上所示，dmtsai 登入并取得终端机名 tty2 之意。
[root@study ~]# who
dmtsai tty2 2015-07-07 23:07
dmtsai pts/0 2015-07-22 00:18 (192.168.1.100)
```
另外，如果您想要知道每个账号的最近登入的时间，则可以使用 lastlog 这个指令喔！ lastlog 会去
读取 /var/log/lastlog 文件，结果将数据输出如下表：
```shell
[root@study ~]# lastlog
Username Port From Latest
root pts/0 Wed Jul 22 00:26:08 +0800 2015
bin **Never logged in**
….(中间省略)….
dmtsai pts/1 192.168.1.100 Wed Jul 22 01:08:07 +0800 2015
vbird1 pts/0 Wed Jul 22 01:32:17 +0800 2015
pro3 **Never logged in**
….(以下省略)….
这样就能够知道每个账号的最近登入的时间啰～ ^_^
```

# 使用者对谈： write, mesg, wall
那么我是否可以跟系统上面的用户谈天说地呢？当然可以啦！利用 write 这个指令即可。 write 可以直接将讯息传给接收者啰！举例来说，我们的 Linux 目前有 vbird1 与 root 两个人在在线， 我的 root 要跟 vbird1 讲话，可以这样做：
```shell
[root@study ~]# write 使用者账号 [用户所在终端接口]
[root@study ~]# who
vbird1 tty3 2015-07-22 01:55 <==有看到 vbird1 在在线
root tty4 2015-07-22 01:56
[root@study ~]# write vbird1 pts/2
Hello, there:
Please don't do anything wrong… <==这两行是 root 写的信息！
# 结束时，请按下 [crtl]-d 来结束输入。此时在 vbird1 的画面中，会出现：
Message from root@study.centos.vbird on tty4 at 01:57 …
Hello, there:
Please don't do anything wrong…
EOF
```
怪怪～立刻会有讯息响应给 vbird1 ！不过……当时 vbird1 正在查资料，哇！这些讯息会立刻打断vbird1 原本的工作喔！所以，如果 vbird1 这个人不想要接受任何讯息，直接下达这个动作：
```shell
[vbird1@study ~]$ mesg n
[vbird1@study ~]$ mesg
is n
```
不过，这个 mesg 的功能对 root 传送来的讯息没有抵挡的能力！所以如果是 root 传送讯息， vbird1还是得要收下。但是如果 root 的 mesg 是 n 的，那么 vbird1 写给 root 的信息会变这样：
```shell
[vbird1@study ~]$ write root
write: root has messages disabled
```
了解乎？如果想要解开的话，再次下达『 `mesg y` 』就好啦！想要知道目前的 mesg 状态，直接下达『 `mesg` 』即可！
相对于 write 是仅针对一个使用者来传『简讯』，我们还可以『对所有系统上面的用户传送简讯 (广播)』～ 如何下达？用 wall 即可啊！他的语法也是很简单的喔！
```shell
[root@study ~]# wall "I will shutdown my linux server…"
```
然后你就会发现所有的人都会收到这个简讯呢！连发送者自己也会收到耶！
# 使用者邮件信箱： mail
使用 wall, write 毕竟要等到使用者在在线才能够进行，有没有其他方式来联络啊？ 不是说每个Linux 主机上面的用户都具有一个 mailbox 吗？ 我们可否寄信给使用者啊！呵呵！当然可以啊！我们可以寄、收 mailbox 内的信件呢！
一般来说， mailbox 都会放置在 /var/spool/mail 里面，一个账号一个 mailbox (文件)。举例来说，我的 vbird1 就具有 /var/spool/mail/vbird1 这个 mailbox 喔！
```shell
[root@study ~]# mail -s "nice to meet you" vbird1
Hello, D.M. Tsai
Nice to meet you in the network.
You are so nice. byebye!
. <==这里很重要喔，结束时，最后一行输入小数点 . 即可！
EOT
[root@study ~]# <==出现提示字符，表示输入完毕了！
```
可以先用 vi 将信件内容编好，然后再以 mail -s "nice to meet you" vbird1 < filename 来将文件内容传输即可。
要收信呢？呵呵！同样的使用 mail 啊！ 假设我以 vbird1 的身份登入主机，然后输入 mail 后，会得到什么？
```shell
[vbird1@study ~]$ mail
Heirloom Mail version 12.5 7/5/10. Type ? for help.
"/var/spool/mail/vbird1": 1 message 1 new
>N 1 root Wed Jul 22 02:09 20/671 "nice to meet you"
& <==这里可以输入很多的指令，如果要查阅，输入 ? 即可！
```
在 mail 当中的提示字符是 & 符号喔，别搞错了～输入 mail 之后，我可以看到我有一封信件，这封信件的前面那个 > 代表目前处理的信件，而在大于符号的右边那个 N 代表该封信件尚未读过，如果我想要知道这个 mail 内部的指令有哪些，可以在 & 之后输入『 ? 』，就可以看到如下的画面：
```shell
& ?
mail commands
type <message list> type messages
next goto and type next message
from <message list> give head lines of messages
headers print out active message headers
delete <message list> delete messages
undelete <message list> undelete messages
save <message list> folder append messages to folder and mark as saved
copy <message list> folder append messages to folder without marking them
write <message list> file append message texts to file, save attachments
preserve <message list> keep incoming messages in mailbox even if saved
Reply <message list> reply to message senders
reply <message list> reply to message senders and all recipients
mail addresses mail to specific recipients
file folder change to another folder
quit quit and apply changes to folder
xit quit and discard changes made to folder
! shell escape
cd <directory> chdir to directory or home if none given
list list names of all available commands
```
![[Pasted image 20241101212938.png]]
