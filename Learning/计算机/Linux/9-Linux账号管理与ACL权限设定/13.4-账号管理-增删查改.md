# 新增与移除使用者： `useradd`, 相关配置文件, `passwd`, `usermod`, `userdel`
## `useradd`
```shell
[root@study ~]# useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM]\
> [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账号名
选项与参数：
-u ：后面接的是 UID ，是一组数字。直接指定一个特定的 UID 给这个账号；
-g ：后面接的那个组名就是我们上面提到的 initial group 啦～
该群组的 GID 会被放置到 /etc/passwd 的第四个字段内。
-G ：后面接的组名则是这个账号还可以加入的群组。
这个选项与参数会修改 /etc/group 内的相关资料喔！
-M ：强制！不要建立用户家目录！(系统账号默认值)
-m ：强制！要建立用户家目录！(一般账号默认值)
-c ：这个就是 /etc/passwd 的第五栏的说明内容啦～可以随便我们设定的啦～
-d ：指定某个目录成为家目录，而不要使用默认值。务必使用绝对路径！
-r ：建立一个系统的账号，这个账号的 UID 会有限制 (参考 /etc/login.defs)
-s ：后面接一个 shell ，若没有指定则预设是 /bin/bash 的啦～
-e ：后面接一个日期，格式为『YYYY-MM-DD』此项目可写入 shadow 第八字段，
亦即账号失效日的设定项目啰；
-f ：后面接 shadow 的第七字段项目，指定密码是否会失效。0 为立刻失效，
-1 为永远不失效(密码只会过期而强制于登入时重新设定而已。)
范例一：完全参考默认值建立一个用户，名称为 vbird1
[root@study ~]# useradd vbird1
[root@study ~]# ll -d /home/vbird1
drwx------. 3 vbird1 vbird1 74 Jul 20 21:50 /home/vbird1
# 默认会建立用户家目录，且权限为 700 ！这是重点！
[root@study ~]# grep vbird1 /etc/passwd /etc/shadow /etc/group
/etc/passwd:vbird1:x:1003:1004::/home/vbird1:/bin/bash
/etc/shadow:vbird1:!!:16636:0:99999:7:::
/etc/group:vbird1:x:1004: <==预设会建立一个与账号一模一样的群组名
```
CentOS 这些默认值主要会帮我们处理几个项目：
- 在 /etc/passwd 里面建立一行与账号相关的数据，包括建立 UID/GID/家目录等；
- 在 /etc/shadow 里面将此账号的密码相关参数填入，但是尚未有密码；
- 在 /etc/group 里面加入一个与账号名称一模一样的组名；
- 在 /home 底下建立一个与账号同名的目录作为用户家目录，且权限为 700

范例二：假设我已知道我的系统当中有个组名为 users ，且 UID 1500 并不存在，
```shell
请用 users 为初始群组，以及 uid 为 1500 来建立一个名为 vbird2 的账号
[root@study ~]# useradd -u 1500 -g users vbird2
[root@study ~]# ll -d /home/vbird2
drwx------. 3 vbird2 users 74 Jul 20 21:52 /home/vbird2
[root@study ~]# grep vbird2 /etc/passwd /etc/shadow /etc/group
/etc/passwd:vbird2:x:1500:100::/home/vbird2:/bin/bash
/etc/shadow:vbird2:!!:16636:0:99999:7:::
# 看一下，UID 与 initial group 确实改变成我们需要的了！
```

`-r ：建立一个系统的账号，这个账号的 UID 会有限制`, 什么是系统账号呢?
```shell
范例三：建立一个系统账号，名称为 vbird3
[root@study ~]# useradd -r vbird3
[root@study ~]# ll -d /home/vbird3
ls: cannot access /home/vbird3: No such file or directorya <==不会主动建立家目录
[root@study ~]# grep vbird3 /etc/passwd /etc/shadow /etc/group
/etc/passwd:vbird3:x:699:699::/home/vbird3:/bin/bash
/etc/shadow:vbird3:!!:16636::::::
/etc/group:vbird3:x:699:
```
- 一般账号是 1000 号以后，加上 -r 这个选项以后，系统就会将账号与账号同名群组的 UID/GID 都指定小于 1000 
- 系统账号默认都不会主动建立家目录

### `useradd` 参考档
#### ` /etc/default/useradd`
其实 useradd 的默认值可以使用底下的方法呼叫出来：
```shell
[root@study ~]# useradd -D
GROUP=100   <==预设的群组
HOME=/home  <==默认的家目录所在目录
INACTIVE=-1 <==密码失效日，在 shadow 内的第 7 栏
EXPIRE=     <==账号失效日，在 shadow 内的第 8 栏
SHELL=/bin/bash <==预设的 shell
SKEL=/etc/skel  <==用户家目录的内容数据参考目录
CREATE_MAIL_SPOOL=yes <==是否主动帮使用者建立邮件信箱(mailbox)
```
这个数据其实是由 `/etc/default/useradd` 呼叫出来的！你可以自行用 vim 去观察该文件的内容。搭配
上头刚刚谈过的范例一的运作结果，上面这些设定项目所造成的行为分别是：
-  `GROUP=100`：新建账号的初始群组使用 GID 为 100 者
	- 系统上面 GID 为 100 者即是 users 这个群组，此设定项目指的就是让新设使用者账号的初始群组为 users 这一个的意思。但是我们知道 CentOS 上面并不是这样的，在 CentOS 上面预设的群组为与账号名相同的群组。举例来说， vbird1 的初始群组为 vbird1 。怎么会这样啊？这是因为针对群组的角度有两种不同的机制所致，这两种机制分别是：
	- *私有群组机制*：
		- 系统会建立一个与账号一样的群组给使用者作为初始群组。这种群组的设定机制会比较有保密性，这是因为使用者都有自己的群组，而且家目录权限将会设定为 700 (仅有自己可进入自己的家目录)之故。使用这种机制将不会参考 GROUP=100 这个设定值。代表性的 distributions 有 RHEL,Fedora, CentOS 等；
	- *公共群组机制*：
		- 就是以 GROUP=100 这个设定值作为新建账号的初始群组，因此每个账号都属于 users 这个群组，且默认家目录通常的权限会是『 drwxr-xr-x … username users … 』，由于每个账号都属于 users 群组，因此大家都可以互相分享家目录内的数据之故。代表 distributions 如 SuSE 等。由于我们的 CentOS 使用私有群组机制，因此这个设定项目是不会生效的！不要太紧张啊！
- `HOME=/home`：用户家目录的基准目录(basedir)
	- 用户的家目录通常是与账号同名的目录，这个目录将会摆放在此设定值的目录后。所以 vbird1 的家目录就会在 /home/vbird1/ 了！很容易理解吧！
- `INACTIVE=-1`：密码过期后是否会失效的设定值
	- 我们在 shadow 文件结构当中谈过，第七个字段的设定值将会影响到密码过期后，在多久时间内还可使用旧密码登入。这个项目就是在指定该日数啦！如果是 0 代表密码过期立刻失效，如果是 -1 则是代表密码永远不会失效，如果是数字，如 30 ，则代表过期 30 天后才失效。
- `EXPIRE=`：账号失效的日期
	- 就是 shadow 内的第八字段，你可以直接设定账号在哪个日期后就直接失效，而不理会密码的问题。通常不会设定此项目，但如果是付费的会员制系统，或许这个字段可以设定喔！
- `SHELL=/bin/bash`：默认使用的 shell 程序文件名
	- 系统默认的 shell 就写在这里。假如你的系统为 mail server ，你希望每个账号都只能使用 email的收发信件功能，而不许用户登入系统取得 shell ，那么可以将这里设定为 /sbin/nologin ，如此一来，新建的使用者预设就无法登入！也免去后续使用 usermod 进行修改的手续！ SKEL=/etc/skel：用户家目录参考基准目录
	- 这个咚咚就是指定用户家目录的参考基准目录啰～举我们的范例一为例， vbird1 家目录/home/vbird1 内的各项数据，都是由 /etc/skel 所复制过去的～所以呢，未来如果我想要让新增使用者时，该用户的环境变量~/.bashrc 就设定妥当的话，您可以到 /etc/skel/.bashrc 去编辑一下，也可以建立 /etc/skel/www 这个目录，那么未来新增使用者后，在他的家目录下就会有 www 那个目录了！这样瞭呼？
- `CREATE_MAIL_SPOOL=yes`：建立使用者的 mailbox
	- 你可以使用『 ll /var/spool/mail/vbird1 』看一下，会发现有这个文件的存在喔！这就是使用者的邮件信箱
	
#### `/etc/login.defs`
除了这些基本的账号设定值之外， UID/GID 还有密码参数又是在哪里参考的呢？那就得要看一下`/etc/login.defs`
```shell
MAIL_DIR /var/spool/mail <==用户默认邮件信箱放置目录
PASS_MAX_DAYS 99999      <==/etc/shadow 内的第 5 栏，多久需变更密码日数
PASS_MIN_DAYS 0 <==/etc/shadow 内的第 4 栏，多久不可重新设定密码日数
PASS_MIN_LEN 5  <==密码最短的字符长度，已被 pam 模块取代，失去效用！
PASS_WARN_AGE 7 <==/etc/shadow 内的第 6 栏，过期前会警告的日数
UID_MIN 1000    <==使用者最小的 UID，意即小于 1000 的 UID 为系统保留
UID_MAX 60000   <==使用者能够用的最大 UID
SYS_UID_MIN 201 <==保留给用户自行设定的系统账号最小值 UID
SYS_UID_MAX 999 <==保留给用户自行设定的系统账号最大值 UID
GID_MIN 1000    <==使用者自定义组的最小 GID，小于 1000 为系统保留
GID_MAX 60000   <==使用者自定义组的最大 GID
SYS_GID_MIN 201 <==保留给用户自行设定的系统账号最小值 GID
SYS_GID_MAX 999 <==保留给用户自行设定的系统账号最大值 GID
CREATE_HOME yes <==在不加 -M 及 -m 时，是否主动建立用户家目录？
UMASK 077       <==用户家目录建立的 umask ，因此权限会是 700
USERGROUPS_ENAB yes   <==使用 userdel 删除时，是否会删除初始群组
ENCRYPT_METHOD SHA512 <==密码加密的机制使用的是 sha512 这一个机制！
```
这个文件规范的数据则是如下所示：
- mailbox 所在目录：
	- 用户的默认 mailbox 文件放置的目录在 /var/spool/mail，所以 vbird1 的 mailbox 就是在/var/spool/mail/vbird1 啰！
- shadow 密码第 4, 5, 6 字段内容：
	- 透过 PASS_MAX_DAYS 等等设定值来指定的！所以你知道为何预设的 /etc/shadow 内每一行都会有『 0:99999:7 』的存在了吗？不过要注意的是，由于目前我们登入时改用 PAM 模块来进行密码检验，所以那个 PASS_MIN_LEN 是失效的！
- UID/GID 指定数值：
	- 虽然 Linux 核心支持的账号可高达 $2^{32}$ 这么多个，不过一部主机要作出这么多账号在管理上也是很麻烦的！所以在这里就针对 UID/GID 的范围进行规范就是了。上表中的 UID_MIN 指的就是可登入系统的一般账号的最小 UID ，至于 UID_MAX 则是最大 UID 之意。要注意的是，系统给予一个账号 UID 时，他是 
	- (1)先参考 UID_MIN 设定值取得最小数值；
	- (2)由/etc/passwd 搜寻最大的 UID 数值，
	- 将 (1) 与 (2) 相比，找出最大的那个再加一就是新账号的 UID 了。我们上面已经作出 UID 为 1500 的 vbird2 ，如果再使用『 useradd vbird4 』时，你猜 vbird4 的 UID 会是多少？答案是： 1501 。所以中间的 1004~1499 的号码就空下来啦！而如果我是想要建立系统用的账号，所以使用 `useradd -r sysaccount` 这个 -r 的选项时，就会找『比 201 大但比 1000 小的最大的 UID 』就是了。 
- 用户家目录设定值：
	- 为何我们系统默认会帮用户建立家目录？就是这个『CREATE_HOME = yes』的设定值啦！这个设定值会让你在使用 useradd 时，主动加入『 -m 』这个产生家目录的选项啊！如果不想要建立用户家目录，就只能强制加上『 -M 』的选项在 useradd 指令执行时啦！至于建立家目录的权限设定呢？就透过 umask 这个设定值啊！因为是 077 的预设设定，因此用户家目录默认权限才会是『 drwx------ 』哩！用户删除与密码设定值：
	- 使用『USERGROUPS_ENAB yes』这个设定值的功能是： 如果使用 userdel 去删除一个账号时，且该账号所属的初始群组已经没有人隶属于该群组了， 那么就删除掉该群组，举例来说，我们刚刚有建立 vbird4 这个账号，他会主动建立 vbird4 这个群组。 若 vbird4 这个群组并没有其他账号将他加入支持的情况下，若使用 userdel vbird4 时，该群组也会被删除的意思。 至于『ENCRYPT_METHOD SHA512』则表示使用SHA512 来加密密码明文，而不使用旧式的 MD5(注 2) 
## `passwd`
```shell
[root@study ~]# passwd [--stdin] [账号名称] <==所有人均可使用来改自己的密码
[root@study ~]# passwd [-l] [-u] [--stdin] [-S] \
> [-n 日数] [-x 日数] [-w 日数] [-i 日期] 账号 <==root 功能
选项与参数：
--stdin ：可以透过来自前一个管线的数据，作为密码输入，对 shell script 有帮助！
-l ：是 Lock 的意思，会将 /etc/shadow 第二栏最前面加上 ! 使密码失效；
-u ：与 -l 相对，是 Unlock 的意思！
-S ：列出密码相关参数，亦即 shadow 文件内的大部分信息。
-n ：后面接天数，shadow 的第 4 字段，多久不可修改密码天数
-x ：后面接天数，shadow 的第 5 字段，多久内必须要更动密码
-w ：后面接天数，shadow 的第 6 字段，密码过期前的警告天数
-i ：后面接『日期』，shadow 的第 7 字段，密码失效日期
范例一：请 root 给予 vbird2 密码
[root@study ~]# passwd vbird2
Changing password for user vbird2.
New UNIX password: <==这里直接输入新的密码，屏幕不会有任何反应
BAD PASSWORD: The password is shorter than 8 characters <==密码太简单或过短的错误！
Retype new UNIX password: <==再输入一次同样的密码
passwd: all authentication tokens updated successfully. <==竟然还是成功修改了！
```
root 果然是最伟大的人物！当我们要给予用户密码时，透过 root 来设定即可。 root 可以设定各式各样的密码，系统几乎一定会接受！所以您瞧瞧，如同上面的范例一，明明鸟哥输入的密码太短了，但是系统依旧可接受 vbird2 这样的密码设定。这个是 root 帮忙设定的结果，那如果是用户自己要改密码呢？ 包括 root 也是这样修改的喔！
```shell
范例二：用 vbird2 登入后，修改 vbird2 自己的密码
[vbird2@study ~]$ passwd <==后面没有加账号，就是改自己的密码！
Changing password for user vbird2.
Changing password for vbird2
(current) UNIX password: <==这里输入『原有的旧密码』
New UNIX password: <==这里输入新密码
BAD PASSWORD: The password is shorter than 8 characters <==密码太短！不可以设定！重新想
New password: <==这里输入新想的密码
BAD PASSWORD: The password fails the dictionary check - it is based on a dictionary word
# 同样的，密码设定在字典里面找的到该字符串，所以也是不建议！无法通过，再想新的！
New UNIX password: <==这里再想个新的密码来输入吧
Retype new UNIX password: <==通过密码验证！所以重复这个密码的输入
passwd: all authentication tokens updated successfully. <==有无成功看关键词
```
passwd 的使用真的要很注意，尤其是 root 先生啊！鸟哥在课堂上每次讲到这里，说是要帮自己的般账号建立密码时， 有一小部分的学生就是会忘记加上账号，结果就变成改变 root 自己的密码最后…. root 密码就这样不见去！唉～ 要帮一般账号建立密码需要使用『 passwd 账号 』的格式，用『 passwd 』表示修改自己的密码！拜托！千万不要改错！
与 root 不同的是，一般账号在更改密码时需要先输入自己的旧密码 (亦即 current 那一行)，然后再输入新密码 (New 那一行)。要注意的是，密码的规范是非常严格的，尤其新的 distributions 大多使用 PAM 模块来进行密码的检验，包括太短、密码与账号相同、密码为字典常见字符串等，都会被PAM 模块检查出来而拒绝修改密码，此时会再重复出现『 New 』这个关键词！那时请再想个新密码！若出现『 Retype 』才是你的密码被接受了！重复输入新密码并且看到『 successfully 』这个关键词时才是修改密码成功喔！
>与一般使用者不同的是， root 并不需要知道旧密码就能够帮用户或 root 自己建立新密码！

新的 distributions 是使用较严格的 PAM 模块来管理密码，这个管理的机制写在 `/etc/pam.d/passwd` 当中。而该文件与密码有关的测试模块就是使用：`pam_cracklib.so`，这个模块会检验密码相关的信息，并且取代 /etc/login.defs 内的 PASS_MIN_LEN的设定
为了方便系统管理，新版的 passwd 还加入了很多创意选项喔！鸟哥个人认为最好用的大概就是这个『 --stdin 』了！ 举例来说，你想要帮 vbird2 变更密码成为 abc543CC ，可以这样下达指令呢！
```shell
范例三：使用 standard input 建立用户的密码
[root@study ~]# echo "abc543CC" | passwd --stdin vbird2
Changing password for user vbird2.
passwd: all authentication tokens updated successfully.
```
这个动作会直接更新用户的密码而不用再次的手动输入！好处是方便处理，缺点是这个密码会保留在指令中，未来若系统被攻破，人家可以在 /root/.bash_history 找到这个密码呢！所以这个动作通常仅用在 shell script 的大量建立使用者账号当中！要注意的是，这个选项并不存在所有 distributions 版本中，请使用 man passwd 确认你的 distribution 是否有支持此选项喔！
## `chage`
除了使用 passwd -S 之外，有没有更详细的密码参数显示功能呢？有的！那就是 chage 了！他的用法如下：
```shell
[root@study ~]# chage [-ldEImMW] 账号名
选项与参数：
-l ：列出该账号的详细密码参数；
-d ：后面接日期，修改 shadow 第三字段(最近一次更改密码的日期)，格式 YYYY-MM-DD
-E ：后面接日期，修改 shadow 第八字段(账号失效日)，格式 YYYY-MM-DD
-I ：后面接天数，修改 shadow 第七字段(密码失效日期)
-m ：后面接天数，修改 shadow 第四字段(密码最短保留天数)
-M ：后面接天数，修改 shadow 第五字段(密码多久需要进行变更)
-W ：后面接天数，修改 shadow 第六字段(密码过期前警告日期)
范例一：列出 vbird2 的详细密码参数
[root@study ~]# chage -l vbird2
Last password change : Jul 20, 2015
Password expires : Sep 18, 2015
Password inactive : Sep 28, 2015
Account expires : never
Minimum number of days between password change : 0
Maximum number of days between password change : 60
Number of days of warning before password expires : 7
```
我们在 passwd 的介绍中谈到了处理 vbird2 这个账号的密码属性流程，使用 passwd -S 却无法看到很清楚的说明。如果使用 chage 那可就明白多了！如上表所示，我们可以清楚的知道 vbird2 的详细参数呢！ 如果想要修改其他的设定值，就自己参考上面的选项，或者自行 man chage 一下吧！
chage 有一个功能很不错喔！如果你想要让『使用者在第一次登入时， 强制她们一定要更改密码后才能够使用系统资源』，可以利用如下的方法来处理的！
```shell
# 范例二：建立一个名为 agetest 的账号，该账号第一次登入后使用默认密码，但必须要更改过密码后，
 使用新密码才能够登入系统使用 bash 环境
[root@study ~]# useradd agetest
[root@study ~]# echo "agetest" | passwd --stdin agetest
[root@study ~]# chage -d 0 agetest
[root@study ~]# chage -l agetest | head -n 3
Last password change : password must be changed
Password expires : password must be changed
Password inactive : password must be changed
# 此时此账号的密码建立时间会被改为 1970/1/1 ，所以会有问题！
范例三：尝试以 agetest 登入的情况
You are required to change your password immediately (root enforced)
WARNING: Your password has expired.
You must change your password now and login again!
Changing password for user agetest.
Changing password for agetest
(current) UNIX password: <==这个账号被强制要求必须要改密码！
非常有趣吧！你会发现 agetest 这个账号在第一次登入时可以使用与账号同名的密码登入， 但登入
时就会被要求立刻更改密码，更改密码完成后就会被踢出系统。再次登入时就能够使用新密码登入了
```