Linux 系统上面的用户如果需要登入主机以取得 shell 的环境来工作
首先，他必须要在计算机前面利用 tty1~tty6 的终端机提供的 login 接口，并输入账号与密码后才能够登入.输入账号密码后，系统帮你处理了什么呢？
1. 先找寻 /etc/passwd 里面是否有你输入的账号？如果没有则跳出，如果有的话则将该账号对应的 UID 与
GID (在 /etc/group 中) 读出来，另外，该账号的家目录与 shell 设定也一并读出；
2. 再来则是核对密码表啦！这时 Linux 会进入 /etc/shadow 里面找出对应的账号与 UID，然后核对一下你刚
刚输入的密码与里头的密码是否相符？
3. 如果一切都 OK 的话，就进入 Shell 控管的阶段

跟使用者账号有关的有两个非常重要的文件，一个是管理使用者 UID/GID重要参数的 /etc/passwd ，一个则是专门管理密码相关数据的 /etc/shadow，详细的说明可以参考 `man 5 passwd` 及 `man 5 shadow`
# /etc/passwd 文件结构
这个文件的构造是这样的：每一行都代表一个账号，有几行就代表有几个账号在你的系统中！不过需要特别留意的是，里头很多账号本来就是系统正常运作所必须要的，我们可以简称他为系统账号，例如 bin, daemon, adm, nobody 等等，这些账号请不要随意的杀掉他呢！这个文件的内容有点像这样：
```shell
[root@study ~]# head -n 4 /etc/passwd
root:x:0:0:root:/root:/bin/bash <==等一下做为底下说明用
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin

名称:密码:UID:GID:说明:家目录:shell
```
![[Pasted image 20241027233927.png]]
![[Pasted image 20241027234345.png]]
每一行使用『:』分隔开，共有七个字段，分别是：
1. 账号名称 `root`：用来提供给对数字不太敏感的人类使用来登入系统的！需要用来对应 UID 喔。例如 root 的UID 对应就是 0 (第三字段)；
2. 密码 `x`：早期 Unix 系统的密码就是放在这字段上！但是因为这个文件的特性是所有的程序都能够读取，这样一来很容易造成密码数据被窃取，因此后来就将这个字段的密码数据给他改放到 /etc/shadow 中了。所以这里你会看到一个『 x 』
3. UID `0`：使用者标识符，通常 Linux 对于 UID 有几个限制需要说给您了解一下：![[Pasted image 20241027233953.png]]
4. GID `0`:与 /etc/group 有关！其实 /etc/group 的观念与 /etc/passwd 差不多，只是他是用来规范组名与 GID 的对应而已！
5. 用户信息说明栏 `root`:这个字段基本上并没有什么重要用途，只是用来解释这个账号的意义而已！不过，如果您提供使用 finger 的功能时， 这个字段可以提供很多的讯息呢！本章后面的 chfn 指令会来解释这里的说明。
6. 家目录 `root`:用户的家目录,如果你有个账号的使用空间特别的大，你想要**将该账号的家目录移动到其他的硬盘**去该怎么作？ 没有错！可以在这个字段进行修改呦！默认的用户家目录在 /home/yourIDname
7. Shell `/bin/bash`:我们在第十章 BASH 提到很多次，当用户登入系统后就会取得一个 Shell 来与系统的核心沟通以进行用户的操作任务。那为何预设 shell 会使用 bash 呢？就是在这个字段指定的啰！ 这里比较需要注意的是，有一个 shell 可以用来替代成让账号无法取得 shell 环境的登入动作！那就是 /sbin/nologin 这个东西！这也可以用来制作纯 pop 邮件账号者的数据呢！
# /etc/shadow
早期的密码也有加密过，但却放置到 /etc/passwd 的第二个字段上！这样一来很容易被有心人士所窃取的，加密过的密码也能够透过暴力破解法去 trial and error (试误) 找出来！因为这样的关系，所以后来发展出将密码移动到 /etc/shadow 这个文件分隔开来的技术，而且还加入很多的密码限制参数在 /etc/shadow 里头
## 字段详解
```shell
[root@study ~]# head -n 4 /etc/shadow
root:$6$wtbCCce/PxMeE5wm$KE2IfSJr.YLP7Rcai6oa/T7KFhO…:16559:0:99999:7::: <==底下说明用
bin:*:16372:0:99999:7:::
daemon:*:16372:0:99999:7:::
adm:*:16372:0:99999:7:::

名称:密码:改密日期:最小改密间隔:强制变更天数:到期前警告天数:到期后有效天数:账号失效日期:保留
```
![[Pasted image 20241027235433.png]]
![[Pasted image 20241027235936.png]]
共有九个字段:
1. 账号名称 `root`：账号，与 /etc/passwd 相同
2. 密码 `*`：经过编码的密码, 你只会看到有一些特殊符号的字母.需要特别留意的是，虽然这些加密过的密码很难被解出来，但是『很难』不等于『不会』，所以，这个文件的预设权限是『-rw-------』或者是『----------』，亦即只有 root 才可以读写.另外，由于各种密码编码的技术不一样，因此不同的编码系统会造成这个字段的长度不相同。举例来说，旧式的 DES, MD5 编码系统产生的密码长度就与目前惯用的 SHA 不同(注 2)！SHA 的密码长度明显的比较长些。**由于固定的编码系统产生的密码长度必须一致，因此『当你让这个字段的长度改变后，该密码就会失效**(算不出来)』。很多软件透过这个功能，在此字段前加上 ! 或 * 改变密码字段长度，就会让密码『暂时失效』了。==由于密码几乎仅能单向运算(由明码计算成为密码，无法由密码反推回明码)，因此由上表的数据我们无法得知 dmstai 的实际密码明文== 
3. 最近更动密码的日期 `19993`：
这个字段记录了『更动密码那一天』的日期,因为计算 Linux 日期的时间是以 1970 年 1 月 1 日作为 1 而累加的日期，上述的 16559 指的就是 2015-05-04 那一天！想要了解该日期可以使用本章后面 chage 指令的帮忙！至于想要知道某个日期的累积日数，可使用如下的程序计算：
```shell
[root@study ~]# echo $(($(date --date="2015/05/04" +%s)/86400+1))
16559

# 上述指令中，2015/05/04 为你想要计算的日期，86400 为每一天的秒数， %s 为 1970/01/01 以来的累积总秒数。 由于 bash 仅支持整数，因此最终需要加上 1 补齐 1970/01/01 当天。
```
4. 密码不可被更动的天数 `0`：(与第 3 字段相比)
第四个字段记录了：这个账号的密码在最近一次被更改后需要经过几天才可以再被变更！如果是 0 的话，表示密码随时可以更动的意思。这的限制是为了怕密码被某些人一改再改而设计的！如果设定为 20 天的话，那么当你设定了密码之后， 20 天之内都无法改变这个密码呦！
5. 密码需要重新变更的天数 `99999`：(与第 3 字段相比)
经常变更密码是个好习惯！为了强制要求用户变更密码，这个字段可以指定在最近一次更改密码后， 在多少天数内需要再次的变更密码才行。你必须要在这个天数内重新设定你的密码，否则这个账号的密码将会『变为过期特性』。 而如果像上面的 99999 (计算为 273 年) 的话，那就表示，呵呵，密码的变更没有强制性之意。
6. 密码需要变更期限前的警告天数 `7`：(与第 5 字段相比)
当账号的密码有效期限快要到的时候 (第 5 字段)，系统会依据这个字段的设定，发出『警告』言论给这个账号，提醒他『再过 n 天你的密码就要过期了，请尽快重新设定你的密码呦！』，如上面的例子，则是密码到期之前的 7 天之内，系统会警告该用户。
7. 密码过期后的账号宽限时间(密码失效日) ` `：(与第 5 字段相比)
密码有效日期为『更新日期(第 3 字段)』+『重新变更日期(第 5 字段)』，过了该期限后用户依旧没有更新密码，那该密码就算过期了。 虽然密码过期但是该账号还是可以用来进行其他工作的，包括登入系统取得bash 。不过如果密码过期了， 那==当你登入系统时，系统会强制要求你必须要重新设定密码才能登入继续使用==喔，这就是密码过期特性。
那这个字段的功能是什么呢？是==在密码过期几天后，如果使用者还是没有登入更改密码==，那么这个账号的密码将会『失效』， 亦即该账号再也无法使用该密码登入了。要注意**密码过期与密码失效并不相同**。
8. 账号失效日期 ` `：
这个日期跟第三个字段一样，都是使用 1970 年以来的总日数设定。这个字段表示： 这个账号在此字段规定的日期之后，将无法再使用。 就是所谓的『账号失效』，此时不论你的密码是否有过期，这个『账号』都不能再被使用！ ==这个字段会被使用通常应该是在『收费服务』的系统中，你可以规定一个日期让该账号不能再使用啦！==
9. 保留：最后一个字段是保留的，看以后有没有新功能加入。
## 改动
由于 shadow 有这样的重要性，因此可不能随意修改.
但在某些情况底下你得要使用各种方法来处理这个文件的！举例来说，常常听到人家说：『我的密码忘记了』，或者是『我的密码不晓得被谁改过，跟原先的不一样了』，这个时候怎么办？
- 一般用户的密码忘记了：这个最容易解决，请系统管理员帮忙，他会重新设定好你的密码而不需要知道你的旧密码！利用 root 的身份使用 passwd 指令来处理即可。
- root 密码忘记了：你无法使用 root 的身份登入了,但我们知道 root 的密码在/etc/shadow 当中，因此你可以使用各种可行的方法开机进入 Linux 再去修改。 例如重新启动进入单人维护模式(第十九章)后，系统会主动的给予 root 权限的 bash 接口， 此时再以 passwd 修改密码即可；或以Live CD 开机后挂载根目录去修改 /etc/shadow，将里面的 root 的密码字段清空， 再重新启动后 root 将不用密码即可登入！登入后再赶快以 passwd 指令去设定 root 密码即可。

另外，由于 Linux 的新旧版本差异颇大，旧的版本 (CentOS 5.x 以前) 还活在很多服务器内！因此，
如果你想要知道 shadow 是使用哪种加密的机制时， 可以透过底下的方法去查询喔！
```shell
[root@study ~]# authconfig --test | grep hashing
password hashing algorithm is sha512

# 这就是目前的密码加密机制！
```