从第五章开始，我们就一直强调 Linux 的权限概念是非常重要的！ 但是传统的权限仅有三种身份(owner, group, others) 搭配三种权限 (r,w,x) 而已，并没有办法单纯的针对某一个使用者或某一个群组来设定特定的权限需求，例如前一小节最后的那个任务！ 此时就得要使用 ACL 这个机制啦！
# 什么是 ACL 与如何支持启动 ACL
ACL 是 Access Control List 的缩写，主要的目的是在提供传统的 owner,group,others 的read,write,execute 权限之外的细部权限设定。ACL 可以针对单一使用者，单一文件或目录来进行r,w,x 的权限规范，对于需要特殊权限的使用状况非常有帮助。
那 ACL 主要可以针对哪些方面来控制权限呢？他主要可以针对几个项目：
- 使用者 (user)：可以针对使用者来设定权限；
- 群组 (group)：针对群组为对象来设定其权限；
- 默认属性 (mask)：还可以针对在该目录下在建立新文件/目录时，规范新数据的默认权限；
也就是说，如果你有一个目录，需要给一堆人使用，每个人或每个群组所需要的权限并不相同时，在过去，传统的 Linux 三种身份的三种权限是无法达到的，因为基本上，==传统的 Linux 权限只能针对一个用户、一个群组及非此群组的其他人设定权限而已，无法针对单一用户或个人来设计权限==。而ACL 就是为了要改变这个问题啊！
## 如何启动 ACL
事实上，原本 ACL 是 unix-like 操作系统的额外支持项目，但因为近年以来 Linux 系统对权限细部设定的热切需求， 因此目前 ACL 几乎已经预设加入在所有常见的 Linux 文件系统的挂载参数中(ext2/ext3/ext4/xfs 等等)！所以你无须进行任何动作， ACL 就可以被你使用啰！不过，如果你不放心系统是否真的有支持 ACL 的话，那么就来检查一下核心挂载时显示的信息吧！
```shell
[root@study ~]# dmesg | grep -i acl
[ 0.330377] systemd[1]: systemd 208 running in system mode. (+PAM +LIBWRAP +AUDIT
+SELINUX +IMA +SYSVINIT +LIBCRYPTSETUP +GCRYPT +ACL +XZ)
[ 0.878265] SGI XFS with ACLs, security attributes, large block/inode numbers, no debug enabled <==瞧！至少 xfs 已经支持这个 ACL 的功能啰！
```
# ACL 的设定技巧： `getfacl`, `setfacl`

- getfacl：取得某个文件/目录的 ACL 设定项目；
- setfacl：设定某个目录/文件的 ACL 规范。
## `setfacl`
`setfacl` 指令用法介绍及最简单的『 u:账号:权限 』设定
```shell
[root@study ~]# setfacl [-bkRd] [{-m|-x} acl 参数] 目标文件名
选项与参数：
-m ：设定后续的 acl 参数给文件使用，不可与 -x 合用；
-x ：删除后续的 acl 参数，不可与 -m 合用；
-b ：移除『所有的』 ACL 设定参数；
-k ：移除『预设的』 ACL 参数，关于所谓的『预设』参数于后续范例中介绍；
-R ：递归设定 acl ，亦即包括次目录都会被设定起来；
-d ：设定『预设 acl 参数』的意思！只对目录有效，在该目录新建的数据会引用此默认值
```
### `setfacl -m u:使用者:rwx file/dirname`
上面谈到的是 acl 的选项功能，那么如何设定 ACL 的特殊权限呢？特殊权限的设定方法有很多，我们先来谈谈最常见的，就是针对单一使用者的设定方式：
```shell
# 1. 针对特定使用者的方式：
# 设定规范：『 u:[使用者账号列表]:[rwx] 』，例如针对 vbird1 的权限规范 rx ：
[root@study ~]# touch acl_test1
[root@study ~]# ll acl_test1
-rw-r--r--. 1 root root 0 Jul 21 17:33 acl_test1
[root@study ~]# setfacl -m u:vbird1:rx acl_test1
[root@study ~]# ll acl_test1
-rw-r-xr--+ 1 root root 0 Jul 21 17:33 acl_test1
# 权限部分多了个 + ，且与原本的权限 (644) 看起来差异很大！但要如何查阅呢？
[root@study ~]# setfacl -m u::rwx acl_test1
[root@study ~]# ll acl_test1
-rwxr-xr--+ 1 root root 0 Jul 21 17:33 acl_test1
# 设定值中的 u 后面无使用者列表，代表设定该文件拥有者，所以上面显示 root 的权限成为 rwx 了!
```
设定前请加上 -m 这个选项。 **如果一个文件设定了 ACL 参数后，他的权限部分就会多出一个 + 号**了！但是此时你看到的权限与实际权限可能就会有点误差！那要如何观察呢？就透过 getfacl 吧！
### `setfacl -m g:群组:rws file/dirname`
```shell
# 2. 针对特定群组的方式：
# 设定规范：『 g:[群组列表]:[rwx] 』，例如针对 mygroup1 的权限规范 rx ：
[root@study ~]# setfacl -m g:mygroup1:rx acl_test1
[root@study ~]# getfacl acl_test1
# file: acl_test1
# owner: root
# group: root
user::rwx
user:vbird1:r-x
group::r--
group:mygroup1:r-x <==这里就是新增的部分！多了这个群组的权限设定！
mask::r-x
other::r--
```
### `setfacl -m m:权限 file/dirname`
使用者或群组所设定的权限必须要存在于 mask 的权限设定范围内才会生效，此即『有效权限(effective permission)』如下所示：
```shell
# 3. 针对有效权限 mask 的设定方式：
# 设定规范：『 m:[rwx] 』，例如针对刚刚的文件规范为仅有 r ：
[root@study ~]# setfacl -m m:r acl_test1
[root@study ~]# getfacl acl_test1
# file: acl_test1
# owner: root
# group: root
user::rwx
user:vbird1:r-x #effective:r-- <==vbird1+mask 均存在者，仅有 r 而已，x 不会生效
group::r--
group:mygroup1:r-x #effective:r--
mask::r--
other::r--
```
通常鸟哥都是将 mask 设定为 rwx 啦！然后再分别依据不同的使用者/群组去规范她们的权限就是了。
### ` d:[u|g]:[user|group]:权限 `:目录 ACL 权限继承
ACL 的权限设定默认不能够被次目录所『继承』
```shell
# 4. 针对预设权限的设定方式：
# 设定规范：『 d:[ug]:使用者列表:[rwx] 』
# 让 myuser1 在 /srv/projecta 底下一直具有 rx 的预设权限！
[root@study ~]# setfacl -m d:u:myuser1:rx /srv/projecta
[root@study ~]# getfacl /srv/projecta
# file: srv/projecta
# owner: root
# group: projecta
# flags: -suser::rwx
user:myuser1:r-x
group::rwx
mask::rwx
other::---
default:user::rwx
default:user:myuser1:r-x
default:group::rwx
default:mask::rwx
default:other::---
```

### 取消 ACL权限
取消全部的 ACL 设定可以使用 -b 来处理，但单一设定值的取消，就得要透过 -x 才行了！所以你应该这样作：
```shell
# 1.1 找到针对 myuser1 的设定值
[root@study ~]# getfacl /srv/projecta | grep myuser1
user:myuser1:r-x
default:user:myuser1:r-x

# 1.2 针对每个设定值来处理，注意，取消某个账号的 ACL 时，不需要加上权限项目！
[root@study ~]# setfacl -x u:myuser1 /srv/projecta
[root@study ~]# setfacl -x d:u:myuser1 /srv/projecta

# 2.1 开始让 pro3 这个用户无法使用该目录啰！
[root@study ~]# setfacl -m u:pro3:- /srv/projecta
```
只需要留意，当设定一个用户/群组没有任何权限的 ACL 语法中，在权限的字段不可留白，而是应该加上一个减号(-) 才是正确的作法！
## `getfacl` 
```shell
[root@study ~]# getfacl filename
选项与参数：
getfacl 的选项几乎与 setfacl 相同！所以鸟哥这里就免去了选项的说明啊！
# 请列出刚刚我们设定的 acl_test1 的权限内容：
[root@study ~]# getfacl acl_test1
# file: acl_test1 <==说明档名而已！
# owner: root <==说明此文件的拥有者，亦即 ls -l 看到的第三使用者字段
# group: root <==此文件的所属群组，亦即 ls -l 看到的第四群组字段
user::rwx <==使用者列表栏是空的，代表文件拥有者的权限
user:vbird1:r-x <==针对 vbird1 的权限设定为 rx ，与拥有者并不同！
group::r-- <==针对文件群组的权限设定仅有 r
mask::r-x <==此文件预设的有效权限 (mask)
other::r-- <==其他人拥有的权限啰！
```
显示的数据前面加上 `#` 的，代表这个文件的默认属性，包括文件名、文件拥有者与文件所属群组。 