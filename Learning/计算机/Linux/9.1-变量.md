
当我们使用 `mail` 指令的时候，系统会给 `MAIL` 变量赋值
![[Learning/计算机/Linux/attachments/Pasted image 20241008161108.png]]
如上图所示，由于**系统已经帮我们规划好 MAIL 这个变量**，所以用户只要知道 `mail` 这个指令如何使用即可， `mail` 会主动的取用 MAIL 这个变量，就能够如上图所示的取得自己的邮件信箱了！(注意大小写，小写的 `mail` 是指令，大写的 MAIL 则是变量名称喔！)
使用 `echo` 来显示变量
## 影响 bash 环境操作的变量
某些特定变量会影响到 bash 的环境！举例来说，我们前面已经提到过很多次的那个 PATH 变数！你能不能在任何目录下执行某个指令，与 PATH 这个变量有很大的关系。例如你下达 ls 这个指令时，系统就是透过 PATH 这个变量里面的内容所记录的路径顺序来搜寻指令的呢！如果在搜寻完PATH 变量内的路径还找不到 ls 这个指令时， 就会在屏幕上显示『 command not found 』的错误讯息了。
如果说的学理一点，那么由于在 Linux System 下面，所有的线程都是需要一个执行码，而就如同上面提到的，==你『真正以 shell 来跟 Linux 沟通，是在正确的登入 Linux 之后！』==
这个时候你就有一个 bash 的执行程序，也才可以真正的经由 bash 来跟系统沟通啰！而==在进入 shell 之前，也正如同上面提到的，由于系统需要一些变量来提供他数据的存取== (或者是一些环境的设定参数值，例如是否要显示彩色等等的) ，所以就有一些所谓的『环境变量』 需要来读入系统中了！这些环境变量例如 PATH、HOME、MAIL、SHELL 等等，都是很重要的，为了区别与自定义变量的不同，环境变量通常以大写字符来表示呢！
## 显示变量，设定变量
`echo ${var}` 和 `echo $var` 都可以，赋值可以直接 `var=…`
在 bash 当中，当一个变量名称尚未被设定时，预设的内容是『空』的
在 bash 的配置文件 `~/.bashrc` 中赋值变量，那每次登入就会自动执行
>每一种 shell 的语法都不相同～在变量的使用上，bash 在你没有设定的变量中强迫去 echo 时，它会显示出空的值。 在其他某些 shell 中，随便去 echo 一个不存在的变量，它是会出现错误讯息的！要注意！要注意！
## 变量的设定规则
1. 变量与变量内容以一个等号『=』来连结，如下所示：`『myname=VBird』`
2. **等号两边不能直接接空格符**，如下所示为错误： `『myname = VBird』` 或 `『myname=VBird Tsai』`
3. 变量名称只能是英文字母与数字，但是**开头字符不能是数字**，如下为错误： `『2myname=VBird』`
4. 变量内容若有空格符可使用双引号『"』或单引号『'』将变量内容结合起来，但
	- **双引号内的特殊字符如 `$` 等，可以保有原本的特性**，如下所示： `『var="lang is $LANG"』` 则 `『echo $var』` 可得 `『lang is zh_TW.UTF-8』`
	- **单引号内的特殊字符则仅为一般字符 (纯文本)**，如下所示：`『var='lang is $LANG'』`则`『echo $var』`可得`『lang is $LANG』`
5. 可用跳脱字符『 `\` 』将特殊符号(如` [Enter], $, \, 空格符, '`等)变成一般字符，如：`『myname=VBird\ Tsai』`
6. 在一串指令的执行中，还需要藉由其他额外的指令所提供的信息时，可以使用反单引号『`指令`』或 『$(指
令)』。 例如想要取得核心版本的设定：`『version=$(uname -r)』`再`『echo $version』`可得`『3.10.0-229.el7.x86_64』`
7. 若该变量为扩增变量内容时，则可用 "`$变量名称`" 或 `${变量}` 累加内容，`:` 表示追加， 如下所示：
`『PATH="$PATH":/home/bin』或『PATH=${PATH}:/home/bin』`（第一个改成单引号不行，我试过了）
8. 若该变量需要在其他子程序执行，则需要**以 `export `来使变量变成环境变量**：`『export PATH』`
9. 通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断 (纯粹依照使用者兴趣与嗜好) ；
10. **取消变量的方法为使用 `unset`** ：`『unset 变量名称』`例如取消 myname 的设定：`『unset myname』`
## 环境变量
-  `env`：列出目前的 shell 环境下的所有环境变量与其内容。如果使用`export`也会是一样的内容～ 只不过， `export`还有其他额外的功能![[Pasted image 20241008171636.png]]
- `set`：查看所有变量，包括环境变量和自定义变量

一般来说，不论是否为环境变量，只要跟我们目前这个 shell 的操作接口有关的变量，通常都会被设定为大写字符，也就是说，『基本上，在 Linux 预设的情况中，使用{大写的字母}来设定的变量一般为系统内定需要的变量』
### 几个比较重要的环境变量
- `PS1`：提示字符，可以用 `man bash` 去查询一下 PS1 的相关说明，以理解底下的一些符号意义。![[Pasted image 20241008172135.png]]
- `$`：关于本 shell 的 PID，钱字号本身也是个变量，代表的是『目前这个 Shell 的线程代号』，亦即是所谓的 PID(Process ID)。想要知道当前 shell 的 PID ，就可以用：『 `echo $$ ` 』即可，出现的数字就是 PID 号码
- `?`：『上一个执行的指令所回传的值』，当执行某些指令时，这些指令会回传一个执行后的代码。一般来说，如果成功的执行该指令，则会回传一个 0 值，如果执行过程发生错误，就会回传『错误代码』，一般是以非 0 的数值来取代。执行一个指令后再 `echo $?` 可以查看上次执行是否成功
## 父程序与子程序
当你登入 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，这个程序的识别使用的是一个称为程序标识符，被称为 PID 的就是。接下来你在这个 bash 底下所下达的任何指令都是由这个 bash 所衍生出来的，那些被下达的指令就被称为子程序了。
![[Pasted image 20241008173606.png]]
如上所示，我们在原本的 bash 底下执行另一个 bash ，结果操作的环境接口会跑到第二个 bash 去(就是子程序)，那原本的 bash 就会在暂停的情况 (睡着了，就是 sleep)。整个指令运作的环境是实线的部分！若要回到原本的 bash 去，就只有将第二个 bash 结束掉 (下达 exit 或 logout) 才行。
子程序仅会继承父程序的环境变量，子程序不会继承父程序的自定义变量，`export 变量名称` 能分享自己的变量设定给后来呼叫的文件或其他程序
如何将环境变量转成自定义变量呢？可以使用 `declare`
