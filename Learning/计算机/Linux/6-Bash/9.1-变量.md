
当我们使用 `mail` 指令的时候，系统会给 `MAIL` 变量赋值
![[Learning/计算机/Linux/attachments/Pasted image 20241008161108.png]]
如上图所示，由于**系统已经帮我们规划好 MAIL 这个变量**，所以用户只要知道 `mail` 这个指令如何使用即可， `mail` 会主动的取用 MAIL 这个变量，就能够如上图所示的取得自己的邮件信箱了！(注意大小写，小写的 `mail` 是指令，大写的 MAIL 则是变量名称喔！)
使用 `echo` 来显示变量
## 影响 bash 环境操作的变量
某些特定变量会影响到 bash 的环境！举例来说，我们前面已经提到过很多次的那个 PATH 变数！你能不能在任何目录下执行某个指令，与 PATH 这个变量有很大的关系。例如你下达 ls 这个指令时，系统就是透过 PATH 这个变量里面的内容所记录的路径顺序来搜寻指令的呢！如果在搜寻完PATH 变量内的路径还找不到 ls 这个指令时， 就会在屏幕上显示『 command not found 』的错误讯息了。
如果说的学理一点，那么由于在 Linux System 下面，所有的线程都是需要一个执行码，而就如同上面提到的，==你『真正以 shell 来跟 Linux 沟通，是在正确的登入 Linux 之后！』==
这个时候你就有一个 bash 的执行程序，也才可以真正的经由 bash 来跟系统沟通啰！而==在进入 shell 之前，也正如同上面提到的，由于系统需要一些变量来提供他数据的存取== (或者是一些环境的设定参数值，例如是否要显示彩色等等的) ，所以就有一些所谓的『环境变量』 需要来读入系统中了！这些环境变量例如 PATH、HOME、MAIL、SHELL 等等，都是很重要的，为了区别与自定义变量的不同，环境变量通常以大写字符来表示呢！
## 显示变量，设定变量
`echo ${var}` 和 `echo $var` 都可以，赋值可以直接 `var=…`
在 bash 当中，当一个变量名称尚未被设定时，预设的内容是『空』的
在 bash 的配置文件 `~/.bashrc` 中赋值变量，那每次登入就会自动执行
>每一种 shell 的语法都不相同～在变量的使用上，bash 在你没有设定的变量中强迫去 echo 时，它会显示出空的值。 在其他某些 shell 中，随便去 echo 一个不存在的变量，它是会出现错误讯息的！要注意！要注意！
## 变量的设定规则
1. 变量与变量内容以一个等号『=』来连结，如下所示：`『myname=VBird』`
2. **等号两边不能直接接空格符**，如下所示为错误： `『myname = VBird』` 或 `『myname=VBird Tsai』`
3. 变量名称只能是英文字母与数字，但是**开头字符不能是数字**，如下为错误： `『2myname=VBird』`
4. 变量内容若有空格符可使用双引号『"』或单引号『'』将变量内容结合起来，但
	- **双引号内的特殊字符如 `$` 等，可以保有原本的特性**，如下所示： `『var="lang is $LANG"』` 则 `『echo $var』` 可得 `『lang is zh_TW.UTF-8』`
	- **单引号内的特殊字符则仅为一般字符 (纯文本)**，如下所示：`『var='lang is $LANG'』`则`『echo $var』`可得`『lang is $LANG』`
5. 可用跳脱字符『 `\` 』将特殊符号(如` [Enter], $, \, 空格符, '`等)变成一般字符，如：`『myname=VBird\ Tsai』`
6. 在一串指令的执行中，还需要藉由其他额外的指令所提供的信息时，可以使用反单引号『`指令`』或 『$(指
令)』。 例如想要取得核心版本的设定：`『version=$(uname -r)』`再`『echo $version』`可得`『3.10.0-229.el7.x86_64』`
7. 若该变量为扩增变量内容时，则可用 "`$变量名称`" 或 `${变量}` 累加内容，
`『PATH="$PATH":/home/bin』或『PATH=${PATH}:/home/bin』`（第一个改成单引号不行，我试过了）
8. 若该变量需要在其他子程序执行，则需要**以 `export `来使变量变成环境变量**：`『export PATH』`
9. 通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断 (纯粹依照使用者兴趣与嗜好) ；
10. **取消变量的方法为使用 `unset`** ：`『unset 变量名称』`例如取消 myname 的设定：`『unset myname』`
## 环境变量
-  `env`：列出目前的 shell 环境下的所有环境变量与其内容。如果使用`export`也会是一样的内容～ 只不过， `export`还有其他额外的功能![[Pasted image 20241008171636.png]]
- `set`：查看所有变量，包括环境变量和自定义变量

一般来说，不论是否为环境变量，只要跟我们目前这个 shell 的操作接口有关的变量，通常都会被设定为大写字符，也就是说，『基本上，在 Linux 预设的情况中，使用{大写的字母}来设定的变量一般为系统内定需要的变量』
### 几个比较重要的环境变量
- `PS1`：提示字符，可以用 `man bash` 去查询一下 PS1 的相关说明，以理解底下的一些符号意义。![[Pasted image 20241008172135.png]]
- `$`：关于本 shell 的 PID，钱字号本身也是个变量，代表的是『目前这个 Shell 的线程代号』，亦即是所谓的 PID(Process ID)。想要知道当前 shell 的 PID ，就可以用：『 `echo $$ ` 』即可，出现的数字就是 PID 号码
- `?`：『上一个执行的指令所回传的值』，当执行某些指令时，这些指令会回传一个执行后的代码。一般来说，如果成功的执行该指令，则会回传一个 0 值，如果执行过程发生错误，就会回传『错误代码』，一般是以非 0 的数值来取代。执行一个指令后再 `echo $?` 可以查看上次执行是否成功
## 父程序与子程序
当你登入 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，这个程序的识别使用的是一个称为程序标识符，被称为 PID 的就是。接下来你在这个 bash 底下所下达的任何指令都是由这个 bash 所衍生出来的，那些被下达的指令就被称为子程序了。
![[Pasted image 20241008173606.png]]
如上所示，我们在原本的 bash 底下执行另一个 bash ，结果操作的环境接口会跑到第二个 bash 去(就是子程序)，那原本的 bash 就会在暂停的情况 (睡着了，就是 sleep)。整个指令运作的环境是实线的部分！若要回到原本的 bash 去，就只有将第二个 bash 结束掉 (下达 exit 或 logout) 才行。
子程序仅会继承父程序的环境变量，子程序不会继承父程序的自定义变量，`export 变量名称` 能分享自己的变量设定给后来呼叫的文件或其他程序
如何将环境变量转成自定义变量呢？可以使用 `declare`
## 变量内容的删除、取代与替换
### 删除
-  `#` 可以用来删除，代表『从变量内容的最前面开始向右删除』，且仅删除最短的那个
- `##`：删除最长的那一个
```shell
echo ${path#/*local/bin:} 
# *匹配任意个字符


# 范例三：我想要删除前面所有的目录，仅保留最后一个目录
echo ${path#/*:}
>>>/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
# 由于一个 # 仅删除掉最短的那个，因此他删除的情况可以用底下的删除线来看：
# ~~/usr/local/bin:~~/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin

echo ${path##/*:}
>>>/home/dmtsai/bin
# 嘿！多加了一个 # 变成 ## 之后，他变成『删除掉最长的那个数据』！亦即是：
# ~~/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:~~/home/dmtsai/bin
```

- `%`：从后面开始删除字符
- `%%`
```shell
# 范例四：我想要删除最后面那个目录，亦即从 : 到 bin 为止的字符串
echo ${path%:*bin}
>>>/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin
# 注意啊！最后面一个目录不见去！
# 这个 % 符号代表由最后面开始向前删除！所以上面得到的结果其实是来自如下：
# /usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin~~:/home/dmtsai/bin~~

# 范例五：那如果我只想要保留第一个目录呢？
echo ${path%%:*bin}
>>>/usr/local/bin
# 同样的， %% 代表的则是最长的符合字符串，所以结果其实是来自如下：
# /usr/local/bin~~:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin~~
```
### 取代
- 两个 `/` 表示替换，`/old/new` 即用 `new` 代替 `old`，只替换第一个
- 开头的 `/` 若有两个，就表示全部替换，`//old/new`，所有的 `old` 全部用 `new` 替换
```shell
echo ${path/sbin/SBIN}
>>>/usr/local/bin:/usr/bin:/usr/local/*SBIN*:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin

echo ${path//sbin/SBIN}
>>>/usr/local/bin:/usr/bin:/usr/local/*SBIN*:/usr/*SBIN*:/home/dmtsai/.local/bin:/home/dmtsai/bin
```
### 内容替换
- 可以用 `echo ${var-xx}` 来判断某个变量是否存在

```shell
范例一：测试一下是否存在 username 这个变量，若不存在则给予 username 内容为 root
[dmtsai@study ~]$ echo ${username}
		<==由于出现空白，所以 username 可能不存在，也可能是空字符串
[dmtsai@study ~]$ username=${username-root}
[dmtsai@study ~]$ echo ${username}
root 	<==因为 username 没有设定，所以主动给予名为 root 的内容。

[dmtsai@study ~]$ username="vbird tsai" <==主动设定 username 的内容
[dmtsai@study ~]$ username=${username-root}
[dmtsai@study ~]$ echo ${username}
vbird tsai <==因为 username 已经设定了，所以使用旧有的设定而不以 root 取代
```

- 上面这种情况，若 `$username` 被设定为了空字符串，就无法正确判断。可以用 `echo ${username:-root}`，若 `$username` 不存在或为空字符串，它都会输出 `root` 取代

>底下的例子当中，那个 var 与 str 为变量，我们想要针对 str 是否有设定来决定 var的值喔！ 一般来说， `str:` 代表『str 没设定或为空的字符串时』；至于 `str` 则仅为『没有该变数』。![[Pasted image 20241011100736.png]]
>表中的 `?` 和 `:` 好像和 C 语言中的三元字符作用相似
>基本上这种变数的测试也能够透过 shell script 内的 if…then… 来处理， 不过既然 bash 有提供这么简单的方法来测试变量，那我们也可以多学一些嘛！ 不过这种变量测试通常是在程序设计当中比较容易出现，如果这里看不懂就先略过，未来有用到判断变量值时，再回来看看吧



