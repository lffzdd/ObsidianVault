我们什么动作都没有进行，但是一进入 bash 就取得一堆有用的变量，这是因为系统有一些环境配置文件案的存在，让 bash 在启动时直接读取这些配置文件，以规划好 bash 的操作环境
而这些配置文件又可以分为全体系统的配置文件以及用户个人偏好配置文件
我们前几个小节谈到的命令别名、自定义的变数，在注销 bash 后就会失效，所以想要保留设定就得要将这些设定写入配置文件
# login 与 non-login shell
- **login shell**：取得 bash 时需要完整的登入流程的，就称为 login shell。举例来说，你要由 tty1 ~ tty6 登入，需要输入用户的账号与密码，此时取得的 bash 就称为『 login shell 』啰；
- **non-login shell**：取得 bash 接口的方法不需要重复登入的举动，举例来说，
	- (1)你以 X window 登入 Linux 后，再以 X 的图形化接口启动终端机，此时那个终端接口并没有需要再次的输入账号与密码，那个 bash 的环境就称为 non-login shell 了。
	- (2)你在原本的 bash 环境下再次下达 bash 这个指令，同样的也没有输入账号密码，那第二个 bash (子程序) 也是 non-login shell 。

为什么要介绍 login, non-login shell 呢？这是因为这两个取得 bash 的情况中，**读取的配置文件数据不一样**。
## login shell
一般来说，login shell 其实只会读取这两个配置文件：
1. `/etc/profile`：这是系统整体的设定，你最好不要修改这个文件；
2. `~/.bash_profile` 或 `~/.bash_login` 或 `~/.profile`：属于使用者个人设定，你要改自己的数据，就写入这里！

### `/etc/profile` (login shell 才会读)
这个配置文件可以利用使用者的标识符 (UID) 来决定很多重要的变量数据，这也是**每个使用者**登入取得 bash 时一定会读取的配置文件！
这个文件设定的变量主要有：
- `$PATH`：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录；
- `$MAIL`：依据账号设定好使用者的 mailbox 到 /var/spool/mail/账号名；
- `$USER`：根据用户的账号设定此一变量内容；
- `$HOSTNAME`：依据主机的 hostname 指令决定此一变量内容；
- `$HISTSIZE `：历史命令记录笔数。CentOS 7.x 设定为 1000 ；
- `umask`：包括 root 默认为 022 而一般用户为 002 等！

**`/etc/profile` 还会去呼叫外部的设定数据**,在 CentOS 7.x 默认的情况下，底下这些数据会依序的被呼叫进来：
-  `/etc/profile.d/*.sh`：只要在 `/etc/profile.d/` 这个目录内且扩展名为 .sh ，且具有 r 的权限，那么该文件就会被 `/etc/profile` 呼叫进来。在 CentOS 7.x 中，==这个目录底下的文件规范了 bash 操作接口的颜色、语系、ll 与 ls 指令的命令别名、vi 的命令别名、which的命令别名等等==。如果需要帮所有使用者设定一些共享的命令别名时，可以在这个目录底下自行建立扩展名为 .sh 的文件，并将所需要的数据写入即可。![[Pasted image 20241012104036.png]] 
	-  `/etc/locale.conf`:这个文件是由 `/etc/profile.d/lang.sh` 呼叫进来的！它决定 bash 预设使用何种语系的重要配置文件，文件里最重要的就是 `LANG/LC_ALL` 这些个变量的设定
	- `/usr/share/bash-completion/completions/*`：记得我们上头谈过 `[tab]` 的妙用吧？除了命令补齐、档名补齐之外，还可以进行指令的选项/参数补齐功能！那就是从这个目录里面找到相对应的指令来处理的！ 其实这个目录底下的内容是由`/etc/profile.d/bash_completion.sh` 这个文件载入的！
	
### `~/.bash_profile`  (login shell 才会读)
bash 在读完了整体环境设定的 `/etc/profile` 并藉此呼叫其他配置文件后，接下来则是会读取使用者的个人配置文件。 在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是：
1. `~/.bash_profile`
2. `~/.bash_login`
3. `~/.profile`
**其实 bash 的 login shell 设定只会读取上面三个文件的其中一个，而读取的顺序则是依照上面的顺序**。也就是说，如果 `~/.bash_profile` 存在，那么其他两个文件不论有无存在，都不会被读取。如果`~/.bash_profile` 不存在才会去读取 `~/.bash_login`，而前两者都不存在才会读取 `~/.profile` 。
会有这么多的文件，其实是因应其他 shell 转换过来的使用者的习惯而已。
`.bash_profile` 的内容：![[Pasted image 20241012110425.png]]
~~这个文件内有设定 PATH 这个变量喔！而且还使用了 export 将 PATH 变成环境变量~~
新版的 `PATH` 设定在 `.bashrc` 里，由于PATH 在 /etc/profile 当中已经设定过，所以在这里就以累加的方式增加用户家目录下的 ~/bin/ 为额外的执行文件放置目录。==这也就是说，你可以将自己建立的执行档放置到你自己家目录下的 ~/bin/ 目录啦！那就可以直接执行该执行档而不需要使用绝对/相对路径来执行该文件==。
- & 我们来看看整个 login shell 的读取流程：![[Pasted image 20241012111350.png]]
#### `source` 或 `.`
## non-login shell - `~/.bashrc`
当取得 non-login shell 时，该 bash 配置文件仅会读取 `~/.bashrc` ，以 root 的身份读取的该文件与一般使用者的会有所不同，在 root 的 `~/.bashrc` 中其实已经规范了较为保险的命令别名了
此外，咱们的 CentOS 7.x 还会主动的呼叫 /etc/bashrc 这个文件喔！为什么需要呼叫 /etc/bashrc 呢？ 因为 /etc/bashrc 帮我们的 bash 定义出底下的数据：
- 依据不同的 UID 规范出 umask 的值；
- 依据不同的 UID 规范出提示字符 (就是 PS1 变量)；
- 呼叫 `/etc/profile.d/*.sh` 的设定
你要注意的是，这个 /etc/bashrc 是 CentOS 特有的 (其实是 Red Hat 系统特有的)，其他不同的distributions 可能会放置在不同的档名就是了。由于这个 ~/.bashrc 会呼叫 /etc/bashrc 及`/etc/profile.d/*.sh `， 所以，万一你没有 ~/.bashrc (可能自己不小心将他删除了)，那么你会发现你的bash 提示字符可能会变成这个样子：`-bash-4.2$`
不要太担心啦！这是正常的，因为你并没有呼叫 /etc/bashrc 来规范 PS1 变量啦！而且这样的情况也不会影响你的 bash 使用。如果你想要将命令提示字符捉回来，那么可以复制 /etc/skel/.bashrc 到你的家目录，再修订一下你所想要的内容，并使用 source 去呼叫 ~/.bashrc ，那你的命令提示字符就会回来啦！
# 其他相关配置文件
- `/etc/man_db.conf`：这个文件乍看之下好像跟 bash 没相关性，但是对于系统管理员来说，却也是很重要的一个文件！这文件的内容 **『规范了使用 man 的时候， man page 的路径到哪里去寻找！』** 所以说的简单一点，这个文件规定了下达 man 的时候，该去哪里查看数据的路径设定！那么什么时候要来修改这个文件呢？如果你是以 tarball 的方式来安装你的数据，那么你的 manpage 可能会放置在 /usr/local/softpackage/man 里头，那个 softpackage 是你的套件名称，这个时候你就得以手动的方式将该路径加到 /etc/man_db.conf 里头，否则使用 man 的时候就会找不到相关的说明档啰。
- `~/.bash_history`：还记得我们在历史命令提到过这个文件吧？预设的情况下，我们的历史命令就记录在这里啊！而这个文件能够记录几笔数据，则与 HISTFILESIZE 这个变数有关啊。每次登入 bash 后，bash 会先读取这个文件，将所有的历史指令读入内存， 因此，当我们登入 bash 后就可以查知上次使用过哪些指令啰。至于更多的历史指令， 请自行回去参考喔！
- `~/.bash_logout`：这个文件则记录了『当我注销 bash 后，系统再帮我做完什么动作后才离开』的意思。 你可以去读取一下这个文件的内容，预设的情况下，注销时， bash 只是帮我们清掉屏幕的讯息而已。 不过，你也可以将一些备份或者是其他你认为重要的工作写在这个文件中 (例如清空暂存盘)， 那么当你离开 Linux 的时候，就可以解决一些烦人的事情啰！