数据流重导向 (redirect) ，就是将某个指令执行后应该要出现在屏幕上的数据，给他传输到其他的地方，例如文件或者是装置 (例如打印机之类的)
![[Pasted image 20241012165453.png]]
我们执行一个指令的时候，这个指令可能会由文件读入资料，经过处理之后，再将数据输出到屏幕上。在上图当中， standard output 与 standard error output 分别代表『标准输出 (STDOUT)』与『标准错误输出 (STDERR)』
# standard output 与 standard error output
简单的说，标准输出指的是『*指令执行所回传的正确的讯息*』，而标准错误输出可理解为『 *指令执行失败后，所回传的错误讯息*』。举个简单例子来说，我们的系统默认有 /etc/crontab 但却无/etc/vbirdsay， 此时若下达『 cat /etc/crontab /etc/vbirdsay 』这个指令时，cat 会进行：
- 标准输出：读取 /etc/crontab 后，将该文件内容显示到屏幕上；
- 标准错误输出：因为无法找到 /etc/vbirdsay，因此在屏幕上显示错误讯息
不管正确或错误的数据都是默认输出到屏幕上，所以屏幕当然是乱乱的！那能不能透过某些机制将这两股数据分开呢？ 当然可以啊！那就是数据流重导向的功能啊！数据流重导向可以将 standard output(简称 stdout) 与 standard error output (简称 stderr) 分别传送到其他的文件或装置去，而分别传送所用的特殊字符则如下所示：
1. 标准输入 (stdin) ：代码为 0 ，使用 < 或 << ；
2. 标准输出 (stdout)：代码为 1 ，使用 > 或 >> ；
3. 标准错误输出(stderr)：代码为 2 ，使用 2> 或 2>> 

- ~ 代码为 0,1,2 表示在脚本和命令行中用于指定不同的数据流，以便于处理和调试程序。
为了理解 stdout 与 stderr ，我们先来进行一个范例的练习：
```shell
范例一：观察你的系统根目录 (/) 下各目录的文件名、权限与属性，并记录下来
[dmtsai@study ~]$ ll / <==此时屏幕会显示出文件名信息
[dmtsai@study ~]$ ll / > ~/rootfile <==屏幕并无任何信息
[dmtsai@study ~]$ ll ~/rootfile <==有个新档被建立了！
-rw-rw-r--. 1 dmtsai dmtsai 1078 Jul 9 18:51 /home/dmtsai/rootfile
```
`rootfile`文件的建立方式是：
1. 该文件 (本例中是 ~/rootfile) 若不存在，系统会自动的将他建立起来，但是
2. 当这个文件存在的时候，那么系统就会先将这个文件内容清空，然后再将数据写入！
3. 也就是若以 > 输出到一个已存在的文件中，那个文件就会被覆盖掉！

那如果想要将数据累加而不想要将旧的数据删除，那该用两个大于的符号 (>>) .
以上面的范例来说，改成『 ` ll / >> ~/rootfile` 』即可。
如此一来，当 (1) ~/rootfile 不存在时系统会主动建立这个文件；(2)若该文件已存在，则数据会在该文件的最下方累加进去！

上面谈到的是 standard output 的正确数据，那如果是 standard error output 的错误数据就透过2> 及 2>> ，同样是覆盖 (2>) 与累加 (2>>) 的特性，我们在刚刚才谈到 stdout 代码是 1 而stderr 代码是 2 ，所以这个 2> 是很容易理解的，而**如果仅存在 > 时，则代表预设的代码为 1** 
也就是说：
- 1> ：以覆盖的方法将『正确的数据』输出到指定的文件或装置上；
- 1>>：以累加的方法将『正确的数据』输出到指定的文件或装置上；
- 2> ：以覆盖的方法将『错误的数据』输出到指定的文件或装置上；
- 2>>：以累加的方法将『错误的数据』输出到指定的文件或装置上
## 正误讯息分开保存
如果错误讯息不加 `2`，就不会输送数据：![[Pasted image 20241012172033.png]]
**且错误讯息若被成功输送进文件就不会显示在屏幕上了**
`1>` 只会传送正确信息，`2>` 只会传送错误信息，因此若执行结果中同时包含正确和错误信息，可以用 `> list_right 2> list_error`，成功将正确和错误信息分开保存
## `/dev/null` 垃圾桶黑洞装置与特殊写法
如果要将错误讯息忽略掉而不显示或储存，这个时候黑洞装置 `/dev/null` 就很重要了！这个 `/dev/null` 可以吃掉任何导向这个装置的信息
```shell
范例四：承范例三，将错误的数据丢弃，屏幕上显示正确的数据
[dmtsai@study ~]$ find /home -name .bashrc 2> /dev/null
/home/dmtsai/.bashrc <==只有 stdout 会显示到屏幕上， stderr 被丢弃了
```

如果要将正确与错误数据通通写入同一个文件，就得要使用特殊的写法
````ad-attention
```shell
范例五：将指令的数据全部写入名为 list 的文件中
[dmtsai@study ~]$ find /home -name .bashrc > list 2> list <==错误
[dmtsai@study ~]$ find /home -name .bashrc > list 2>&1 <==正确
[dmtsai@study ~]$ find /home -name .bashrc &> list <==正确
```
````
上述表格第一行错误的原因是，**由于两股数据同时写入一个文件，又没有使用特殊的语法，此时两股数据可能会交叉写入该文件内，造成次序的错乱**。所以虽然最终 list 文件还是会产生，但是里面的数据排列就会怪怪的，而不是原本屏幕上的输出排序

在重定向输出时，`&` 用于指示文件描述符。例如：`command > output.txt 2>&1`  
这里，`2` 表示标准错误输出，`1` 表示标准输出，`2>&1` 表示将标准错误输出**重定向到标准输出**，这样两个输出都会被写入到 `output.txt` 文件。
而 `&>` 是一个**简化的重定向语法**，用于同时重定向标准输出 (stdout) 和标准错误输出 (stderr) 到同一个文件。这种语法不在所有的 shell 中都可用，主要是在 Bash 中有效。
# standard input ： < 与 <<
了解了 stderr 与 stdout 后，那么那个 < 又是什么呀？呵呵！以最简单的说法来说，那就是『**将原本需要由键盘输入的数据，改由文件内容来取代**』的意思。
cat 能够直接在命令行建立和写入文件，我们先由底下的 cat 指令操作来了解一下什么叫做『键盘输入』吧！
```shell
范例六：利用 cat 指令来建立一个文件的简单流程
[dmtsai@study ~]$ cat > catfile
testing
cat file test
<==这里按下 [ctrl]+d 来离开
[dmtsai@study ~]$ cat catfile
testing
cat file test
```
由于加入 > 在 cat 后，所以那个 catfile 会被主动的建立，而内容就是刚刚键盘上面输入的那两行数据了，而我们可以用纯文本文件取代键盘的输入：
```shell
范例七：用 stdin 取代键盘的输入以建立新文件的简单流程
[dmtsai@study ~]$ cat > catfile < ~/.bashrc
[dmtsai@study ~]$ ll catfile ~/.bashrc
-rw-r--r--. 1 dmtsai dmtsai 231 Mar 6 06:06 /home/dmtsai/.bashrc
-rw-rw-r--. 1 dmtsai dmtsai 231 Jul 9 18:58 catfile
# 注意看，这两个文件的大小会一模一样！几乎像是使用 cp 来复制一般！
```
  理解 < 之后，再来则是怪可怕一把的 << 这个连续两个小于的符号了。 他代表的是『结束的输入字符』的意思！举例来讲：『我要用 cat 直接将输入的讯息输出到 catfile 中， 且当由键盘输入 eof 时，该次输入就结束』，那我可以这样做：
```shell
[dmtsai@study ~]$ cat > catfile << "eof"
> This is a test.
> OK now stop
> eof <==输入这关键词，立刻就结束而不需要输入 [ctrl]+d
[dmtsai@study ~]$ cat catfile
This is a test.
OK now stop <==只有这两行，不会存在关键词那一行！
```
看到了吗？利用 << 右侧的控制字符，我们可以终止一次输入，而不必输入 `[crtl]+d` 来结束哩！这对程序写作很有帮助喔！
# 总结
好了，那么为何要使用命令输出重导向呢？我们来说一说吧

- 屏幕输出的信息很重要，而且我们需要将他存下来的时候；
- 背景执行中的程序，不希望他干扰屏幕正常的输出结果时；
- 一些系统的例行命令 (例如写在 /etc/crontab 中的文件) 的执行结果，希望他可以存下来时；
- 一些执行命令的可能已知错误讯息时，想以『 2> /dev/null 』将他丢掉时；
- 错误讯息与正确讯息需要分别输出时。

当然还有很多的功能的，最简单的就是网友们常常问到的：『为何我的 root 都会收到系统 crontab 寄来的错误讯息呢』这个咚咚是常见的错误， 而如果我们已经知道这个错误讯息是可以忽略的时候，嗯！『 2> errorfile 』这个功能就很重要了吧！ 了解了吗？