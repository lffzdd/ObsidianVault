---
aliases: 5.5-文件系统指令
tags:
date created: Saturday, September 21st 2024, 9:30:51 am
date modified: Monday, September 23rd 2024, 12:07:44 pm
---
- `fdisk -l` ：查看磁盘
- `parted`
- `df`：列出文件系统的整体磁盘使用量；
- `du`：评估文件系统的磁盘使用量 (常用在推估目录所占容量)
- `lsblk`：查看装置关系和挂载点
- `blkid`: 查看装置的文件系统和 UUID
- `fdisk`：MBR 分区
- `gdisk`：GPT 分区
## 磁盘格式化
分区完毕后要进行文件系统的格式化！格式化的指令非常的简单，那就是『make filesystem,mkfs』 这个指令
- `mkfs.xfs /dev/vda4`: 将前一小节分区出来的 /dev/vda4 格式化为 xfs 文件系统
- `mkfs.ext4 /dev/vda5`
- 按 `mkfs[tab][tab]` 会列出相关指令
## 文件系统检验
> 注意：通常只有身为 root 且你的文件系统有问题的时候才使用这个指令，否则在正常状况下使用此一指令， 可能会造成对系统的危害！
- `xfs_repair /dev/vda4`：检查一下刚刚建立的 /dev/vda4 文件系统，可以加上 option 进行修复操作
- `fsck`：按两个 `Tab` 显示出各个子命令
## 文件系统挂载与卸除
##### 挂载
要作为挂载点的目录，理论上应该都是空目录才是。
```shell
mount -a
mount [-l]
mount [-t 文件系统] LABEL='' 挂载点
mount [-t 文件系统] UUID='' 挂载点 # 鸟哥近期建议用这种方式喔！
mount [-t 文件系统] 装置文件名 挂载点
```
**实例**
```shell
# 找出 /dev/vda4 的 UUID 后，用该 UUID 来挂载文件系统到 /data/xfs 内
blkid /dev/vda4
/dev/vda4: UUID="e0a6af55-26e7-4cb7-a515-826a8bd29e90" TYPE="xfs"
mount UUID="e0a6af55-26e7-4cb7-a515-826a8bd29e90" /data/xf 
```
**重新挂载根目录与不特定目录**
```shell
# 范例：将 / 重新挂载，并加入参数为 rw 与 auto
mount -o remount,rw,auto /
# 将 /var 这个目录暂时挂载到 /data/var 底下
mount --bind /var /data/var
```
##### 卸除
```shell
# 范例：将本章之前自行挂载的文件系统全部卸除：
mount
…..(前面省略)…..
/dev/vda4 on /data/xfs type xfs (rw,relatime,seclabel,attr2,inode64,logbsize=256k,sunit=512,..)
/dev/vda5 on /data/ext4 type ext4 (rw,relatime,seclabel,data=ordered)
/dev/sr0 on /data/cdrom type iso9660 (ro,relatime)
/dev/sda1 on /data/usb type vfat (rw,relatime,fmask=0022,dmask=0022,codepage=950,iocharset=…)
/dev/mapper/centos-root on /data/var type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
# 先找一下已经挂载的文件系统，如上所示，特殊字体即为刚刚挂载的装置啰！
# 基本上，卸除后面接装置或挂载点都可以！不过最后一个 centos-root 由于有其他挂载，
# 因此，该项目一定要使用挂载点来卸除才行！
umount /dev/vda4 <==用装置文件名来卸除
umount /data/ext4 <==挂载点来卸除
umount /data/cdrom <==因为挂载点比较好记忆！
umount /data/usb
umount /data/var <==一定要用挂载点！因为装置有被其他方式挂载
```
## 设定装置 major 和 minor
在 Linux 底下所有的装置都以文件来代表，文件如何代表该装置呢？很简单，就是透过文件的 major 与 minor 数值来替代的
![[Pasted image 20240923105102.png]]
其中，241 和 259 是 major，0,0~6 是 minor
```shell
mknod 装置文件名 [bcp] [Major] [Minor]
# 选项与参数：
# 装置种类：
# b ：设定装置名称成为一个周边储存设备文件，例如磁盘等；
# c ：设定装置名称成为一个周边输入设备文件，例如鼠标/键盘等；
# p ：设定装置名称成为一个 FIFO 文件；
# Major ：主要装置代码；
# Minor ：次要装置代码；
# 设定一个FIFO
mknod /tmp/testpipe p
ll /tmp/testpipe
prw-r--r--. 1 root root 0 Jun 24 23:44 /tmp/testpipe
# 测试完毕之后请删除这个文件吧！看一下这个文件的类型！是 p 喔！^_^
[root@study ~]# rm /dev/vda10 /tmp/testpi
```
## 修改文件系统的 `UUID` 和 `Label name`
- `xfs_admin` 修改 xfs 文件系统，查看 uuid
- `tune2fs` 修改 ext 4 文件系统
```shell
xfs_admin [-lu] [-L label] [-U uuid] 装置文件名
选项与参数：
-l ：列出这个装置的 label name
-u ：列出这个装置的 UUID
-L ：设定这个装置的 Label name
-U ：设定这个装置的 UUID 喔！
tune2fs [-l] [-L Label] [-U uuid] 装置文件名
```
## 设定开机挂载
每次开机文件系统都需要重新挂载，而 ` /etc/fstab` 里面指定了自动挂载的内容，这样就不需要每次启动就手动挂载
```shell
cat /etc/fstab
# Device Mount point filesystem parameters dump fsck
# /dev/mapper/centos-root / xfs defaults 0 0
# UUID=94ac5f77-cb8a-495e-a65b-2ef7442b837c /boot xfs defaults 0 0
# /dev/mapper/centos-home /home xfs defaults 0 0
# /dev/mapper/centos-swap swap swap defaults 0 0
#　dump 指对备份用指令的支持，dump是备份指令，现在有太多的备份方案，直接输入0就可以了
# fsck 指开机时是否进行文件系统检验，我们现在用的 xfs 文件系统无法适用，且 xfs会自己进行检验，所以直接填 0 就好了
# parameters 是文件系统参数，就是 [mount] 指令的参数 
```
`/etc/fstab` 是开机时的配置文件，不过，实际 filesystem 的挂载是记录到 ``/etc/mtab`` 与 `/proc/mounts` 这两个文件当中的。每次我们在更动 filesystem 的挂载时，也会同时更动这两个文件！但是，万一在 `/etc/fstab` 输入的数据错误，导致无法顺利开机成功，而进入单人维护模式当中，那时候的 `/ ` 可是 read only 的状态，当然你就无法修改 `/etc/fstab` ，也无法更新 `/etc/mtab` 啰～那怎么办？没关系，可以利用底下这一招：
`[root@study ~]# mount -n -o remount,rw /`
## 特殊装置挂载
##### 挂载光盘/DVD 映象文件
> 如果今天我们从国家高速网络中心 (<http://ftp.twaren.net>) 或者是昆山科大 (<http://ftp.ksu.edu.tw>) 下载了 Linux 或者是其他所需光盘/DVD 的映象文件后，难道一定需要刻录成为光盘才能够使用该文件里面的数据吗？当然不是啦！我们可以透过 loop 装置来挂载的！
```shell
ll -h /tmp/CentOS-7.0-1406-x86_64-DVD.iso
>>>-rw-r--r--. 1 root root 3.9G Jul 7 2014 /tmp/CentOS-7.0-1406-x86_64-DVD.iso
mount -o loop /tmp/CentOS-7.0-1406-x86_64-DVD.iso /data/centos_dvd
df /data/centos_dvd
ll /data/centos_dvd
```

##### 建立大文件以制作 loop 装置文件！
>既然能够挂载 DVD 的映象档，我们也能制作出一个大文件，然后将这个文件格式化后挂载
```shell
# 1.建立大型文件，用`dd`建立大型空文件
dd if=/dev/zero of=/srv/loopdev bs=1M count=512
>>>512+0 records in <==读入 512 笔资料
>>>512+0 records out <==输出 512 笔数据
>>>536870912 bytes (537 MB) copied, 12.3484 seconds, 43.5 MB/s
# 这个指令的简单意义如下：
# if 是 input file ，输入文件。那个 /dev/zero 是会一直输出 0 的装置！
# of 是 output file ，将一堆零写入到后面接的文件中。
# bs 是每个 block 大小，就像文件系统那样的 block 意义；
# count 则是总共几个 bs 的意思。所以 bs*count 就是这个文件的容量了！

ll -h /srv/loopdev
-rw-r--r--. 1 root root 512M Jun 25 19:46 /srv/loopdev
dd 就好像在迭砖块一样，将 512 块，每块 1MB 的砖块堆栈成为一个大文件 (/srv/loopdev) ！ 最终就会出现一个 512MB 的文件

# 2.大型文件的格式化
mkfs.xfs -f /srv/loopdev
blkid /srv/loopdev
>>>/srv/loopdev: UUID="7dd97bd2-4446-48fd-9d23-a8b03ffdd5ee" TYPE="xfs"

# 3.挂载
mount -o loop UUID="7dd97bd2-4446-48fd-9d23-a8b03ffdd5ee" /mnt
df /mnt
>>>Filesystem 1K-blocks Used Available Use% Mounted on
>>>/dev/loop0 520876 26372 494504 6% /mnt

#现在你不需要下达 -o loop 这个选项与参数，它同样可以被系统挂上来！ 不过，为了考虑向下兼容性，还是建议加上 loop 比较妥当！ 

# 现在，将这个文件系统永远的自动挂载起来
nano /etc/fstab
>>>/srv/loopdev /data/file xfs defaults,loop 0 0
```