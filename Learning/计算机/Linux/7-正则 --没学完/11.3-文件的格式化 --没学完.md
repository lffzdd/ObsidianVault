第 509页
# `printf`
```shell
[dmtsai@study ~]$ printf '打印格式' 实际内容
选项与参数：
关于格式方面的几个特殊样式：
\a 警告声音输出
\b 退格键(backspace)
\f 清除屏幕 (form feed)
\n 输出新的一行
\r 亦即 Enter 按键
\t 水平的 [tab] 按键
\v 垂直的 [tab] 按键
\xNN NN 为两位数的数字，可以转换数字成为字符。
关于 C 程序语言内，常见的变数格式
%ns 那个 n 是数字， s 代表 string ，亦即多少个字符；
%ni 那个 n 是数字， i 代表 integer ，亦即多少整数字数；
%N.nf 那个 n 与 N 都是数字， f 代表 floating (浮点)，如果有小数字数，
假设我共要十个位数，但小数点有两位，即为 %10.2f 啰！
```
范例一：将刚刚上头数据的文件 (printf.txt) 内容仅列出姓名与成绩：(用 `[tab]` 分隔)
```shell
[dmtsai@study ~]$ printf '%s\t %s\t %s\t %s\t %s\t \n' $(cat printf.txt)
# %s 代表一个不固定长度的字符串
# 由于 \t 与 %s 中间还有空格，因此每个字符串间会有一个 [tab] 与一个空格键的分隔
Name Chinese English Math Average
DmTsai 80 60 92 77.33
VBird 75 55 80 70.00
Ken 60 90 70 73.33
```
范例二：将上述资料关于第二行以后，分别以字符串、整数、小数点来显示：
```shell
[dmtsai@study ~]$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt | grep -v Name)
DmTsai 80 60 92 77.33
VBird 75 55 80 70.00
Ken 60 90 70 73.33

# %10s代表的是一个长度为 10 个字符的字符串字段，%5i 代表的是长度为 5 个字符的数字字段，至于那个 %8.2f 则代表长度为 8 个字符的具有小数点的字段，其中小数点有两个字符宽度。
```
printf 除了可以格式化处理之外，他还可以依据 ASCII 的数字与图形对应来显示数据
范例三：列出 16 进位数值 45 代表的字符为何？
```shell
[dmtsai@study ~]$ printf '\x45\n'
E
# 这东西也很好玩～他可以将数值转换成为字符，如果你会写 script 的话，
# 可以自行测试一下，由 20~80 之间的数值代表的字符是啥喔！ ^_^
```
# `awk`
相较于 sed 常常作用于一整个行的处理， awk 则比较倾向于一行当中分成数个『字段』来处理。因此，awk 相当的适合处理小型的数据数据处理
-  `[dmtsai@study ~]$ awk '条件类型 1{动作 1} 条件类型 2{动作 2} …' filename`
 awk 主要是处理『每一行的字段内的数据』，而默认的『字段的分隔符为 "空格键" 或 "`[tab]`键" 』
 ```shell
 [dmtsai@study ~]$ last -n 5 <==仅取出前五行
dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in
dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)
dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)
dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)
dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)
若我想要取出账号与登入者的 IP ，且账号与 IP 之间以 [tab] 隔开，则会变成这样：
[dmtsai@study ~]$ last -n 5 | awk '{print $1 "\t" $3}'
dmtsai 192.168.1.100
dmtsai 192.168.1.100
dmtsai 192.168.1.100
dmtsai 192.168.1.100
dmtsai Fri
上表是 awk 最常使用的动作
 ```
在 awk 的括号内，每一行的每个字段都是有变量名称的，那就是 $1, $2… 等变量名称。以上面的例子来说， dmtsai 是 $1 ，因为他是第一栏嘛！至于 192.168.1.100是第三栏，所以他就是 $3 ,后面以此类推～！还有个变数 $0 ，$0 代表『一整列资料』的意思
整个 awk 的处理流程是：
1. 读入第一行，并将第一行的资料填入 $0, $1, $2…. 等变数当中；
2. 依据 "条件类型" 的限制，判断是否需要进行后面的 "动作"；
3. 做完所有的动作与条件类型；
4. 若还有后续的『行』的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止。
==awk 是『以行为一次处理的单位』，而『以字段为最小的处理单位』==
awk 怎么知道我到底这个数据有几行？有几栏呢？这就需要 awk 的内建变量

| 变量名称 | 代表意义                |
| ---- | ------------------- |
| NF   | 每一行 ($0) 拥有的字段总数    |
| NR   | 目前 awk 所处理的是『第几行』数据 |
| FS   | 目前的分隔字符，默认是空格键      |
我们继续以上面 last -n 5 的例子来做说明，如果我想要：
- 列出每一行的账号(就是 $1)；
- 列出目前处理的行数(就是 awk 内的 NR 变量)
- 并且说明，该行有多少字段(就是 awk 内的 NF 变量)
则可以这样：
```shell
[dmtsai@study ~]$ last -n 5| awk '{print $1 "\t lines: " NR "\t columns: " NF}'
dmtsai lines: 1 columns: 10
dmtsai lines: 2 columns: 10
dmtsai lines: 3 columns: 10
dmtsai lines: 4 columns: 10
dmtsai lines: 5 columns: 9
# 注意喔，在 awk 内的 NR, NF 等变量要用大写，且不需要有钱字号 $ 啦！
```
>要注意喔，awk 后续的所有动作是以单引号『 ' 』括住的，由于单引号与双引号都必须是成对的， 所以， awk 的格式内容如果想要以 print 打印时，记得非变量的文字部分，包含上一小节 printf 提到的格式中，都需要使用双引号来定义出来喔！因为单引号已经是 awk 的指令固定用法了！
## 条件类型
![[Pasted image 20241025123112.png]]
举例来说，在 /etc/passwd 当中是以冒号 ": " 来作为字段的分隔，该文件中第一字段为账号，第三字段则是 UID。那假设我要查阅，第三栏小于 10 以下的数据，并且仅列出账号与第三栏，那么可以这样做：
没搞完, 第 514 页