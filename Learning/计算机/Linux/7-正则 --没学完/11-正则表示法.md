## `grep` 的进阶选项
```shell
[dmtsai@study ~]$ grep [-A] [-B] [--color=auto] '搜寻字符串' filename
选项与参数：
-A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；
-B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来；
--color=auto 可将正确的那个撷取数据列出颜色
范例一：用 dmesg 列出核心讯息，再以 grep 找出内含 qxl 那行
[dmtsai@study ~]$ dmesg | grep 'qxl'
[ 0.522749] [drm] qxl: 16M of VRAM memory size
[ 0.522750] [drm] qxl: 63M of IO pages memory ready (VRAM domain)
[ 0.522750] [drm] qxl: 32M of Surface memory size
[ 0.650714] fbcon: qxldrmfb (fb0) is primary device
[ 0.668487] qxl 0000:00:02.0: fb0: qxldrmfb frame buffer device
# dmesg 可列出核心产生的讯息！包括硬件侦测的流程也会显示出来。
# 鸟哥使用的显卡是 QXL 这个虚拟卡，透过 grep 来 qxl 的相关信息，可发现如上信息。
范例二：承上题，要将捉到的关键词显色，且加上行号来表示：
[dmtsai@study ~]$ dmesg | grep -n --color=auto 'qxl'
515:[ 0.522749] [drm] qxl: 16M of VRAM memory size
516:[ 0.522750] [drm] qxl: 63M of IO pages memory ready (VRAM domain)
517:[ 0.522750] [drm] qxl: 32M of Surface memory size
529:[ 0.650714] fbcon: qxldrmfb (fb0) is primary device
539:[ 0.668487] qxl 0000:00:02.0: fb0: qxldrmfb frame buffer device
# 除了 qxl 会有特殊颜色来表示之外，最前面还有行号喔！其实颜色显示已经是默认在 alias 当中了！
范例三：承上题，在关键词所在行的前两行与后三行也一起捉出来显示
[dmtsai@study ~]$ dmesg | grep -n -A3 -B2 --color=auto 'qxl'
# 你会发现关键词之前与之后的数行也被显示出来！这样可以让你将关键词前后数据捉出来进行分析啦
```
## 语系对正规表示法的影响
为什么语系的数据会影响到正规表示法的输出结果呢？
文件其实记录的仅有 0 与 1，我们看到的字符文字与数字都是透过编码表转换来的。由于不同语系的编码数据并不相同，所以就会造成数据撷取结果的差异了。 举例来说，在英文大小写的编码顺序中，zh_TW.big5 及 C 这两种语系的输出结果分别如下：
- LANG=C 时：0 1 2 3 4 … A B C D … Z a b c d …z
- LANG=zh_TW 时：0 1 2 3 4 … a A b B c C d D … z Z
上面的顺序是编码的顺序，我们可以很清楚的发现这两种语系明显就是不一样！如果你想要撷取大写字符而使用 `[A-Z]` 时， 会发现 LANG=C 确实可以仅捉到大写字符 (因为是连续的) ，但是如果LANG=zh_TW.big5 时，就会发现到， 连同小写的 b-z 也会被撷取出来！因为就编码的顺序来看，big5 语系可以撷取到『 A b B c C … z Z 』这一堆字符哩！ 所以，使用正规表示法时，需要特别留意当时环境的语系为何， 否则可能会发现与别人不相同的撷取结果喔！
# 正则表达式的使用
| 特殊符号         | 代表意义                                            |
| ------------ | ----------------------------------------------- |
| `[:alnum:]`  | 代表英文大小写字符及数字，亦即 0-9, A-Z, a-z                   |
| `[:alpha:]`  | 代表任何英文大小写字符，亦即 A-Z, a-z                         |
| `[:blank:]`  | 代表空格键与 `[Tab]` 按键                               |
| `[:cntrl:]`  | 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del..  等          |
| `[:digit:]`  | 代表数字而已，亦即1 -9                                   |
| `[:graph:]`  | 除了空格符 (空格键与 `[Tab]` 按键) 外的其有按键                  |
| `[:lower:]`  | 代表小写字符， a-z                                     |
| `[:print:]`  | 代表任何可以被打印出来的字符                                  |
| `[:punct:]`  | 代表标点符号 (punctuation symbol)，亦即：" ' ? ! ; : # $… |
| `[:upper:]`  | 代表大写，亦即 A-Z                                     |
| `[:space:]`  | 任何会产生空白的字符，包括空格键, `[Tab]`, CR 等等                |
| `[:xdigit:]` | 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字符        |
## 搜寻特定字符串
假设我们要从刚刚的文件当中取得 the 这个特定字符串，最简单的方式就是这样：
```shell
[dmtsai@study ~]$ grep -n 'the' regular_express.txt
8:I can't finish the test.
12:the symbol '*' is represented as start.
15:You are the best is mean you are the no. 1.
16:The world <Happy> is the same with "glad".
18:google is the best tools for search keyword.
那如果想要『反向选择』呢？也就是说，当该行没有 'the' 这个字符串时才显示在屏幕上，那就直接
使用：
[dmtsai@study ~]$ grep -vn 'the' regular_express.txt
```
你会发现，屏幕上出现的行列为除了 8,12,15,16,18 五行之外的其他行列！接下来，如果你想要取得不论大小写的 the 这个字符串，则：
```shell
[dmtsai@study ~]$ grep -in 'the' regular_express.txt
8:I can't finish the test.
9:Oh! The soup taste good.
12:the symbol '*' is represented as start.
14:The gd software is a library for drafting programs.
15:You are the best is mean you are the no. 1.
16:The world <Happy> is the same with "glad".
18:google is the best tools for search keyword.
```
除了多两行 (9, 14 行) 之外，第 16 行也多了一个 The 的关键词被撷取到喔！
## 利用中括号 [] 来搜寻集合字符
如果我想要搜寻 test 或 taste 这两个单字时，可以发现到，其实她们有共通的 't?st' 存在～这个时候，
我可以这样来搜寻：
```shell
[dmtsai@study ~]$ grep -n 't[ae]st' regular_express.txt
8:I can't finish the test.
9:Oh! The soup taste good.
```
**`[]` 里面不论有几个字符，他都仅代表某『一个』字符**
而如果想要搜寻到有 oo 的字符时，则使用：
```shell
[dmtsai@study ~]$ grep -n 'oo' regular_express.txt
1:"Open Source" is a good mechanism to develop programs.
2:apple is my favorite food.
3:Football game is not use feet only.
9:Oh! The soup taste good.
18:google is the best tools for search keyword.
19: goooooogle yes!
```
但是，如果我不想要 oo 前面有 g 的话呢？此时，可以利用在集合字符的反向选择 [^] 来达成：
```shell
[dmtsai@study ~]$ grep -n '[^g]oo' regular_express.txt
2:apple is my favorite food.
3:Football game is not use feet only.
18:google is the best tools for search keyword.
19: goooooogle yes!
```
意思就是说，我需要的是 oo ，但是 oo 前面不能是 g 就是了！
但是第 18 行明明有 google 的 goo 啊～别忘记了，**因为该行后面出现了 tool 的 too** 啊！所以该行也被列出来～ 也就是说， 18 行里面虽然出现了我们所不要的项目 (goo) 但是由于有需要的项目(too) ，因此，是符合字符串搜寻的喔！
再来，假设我 oo 前面不想要有小写字符，所以，我可以这样写 `[^abcd….z]oo` ，但是这样似乎不怎么方便，由于小写字符的 ASCII 上编码的顺序是连续的，因此，我们可以将之简化为底下这样：
```shell
[dmtsai@study ~]$ grep -n '[^a-z]oo' regular_express.txt
3:Football game is not use feet only.
```
也就是说，当我们在一组集合字符中，如果该字符组是连续的，例如大写英文/小写英文/数字等等， 就可以使用`[a-z],[A-Z],[0-9]`等方式来书写，那么如果我们的要求字符串是数字与英文呢？ 呵呵！就将他全部写在一起，变成：`[a-zA-Z0-9]`。例如，我们要取得有数字的那一行，就这样：
```shell
[dmtsai@study ~]$ grep -n '[0-9]' regular_express.txt
```
**考虑到语系对于编码顺序的影响**，因此除了连续编码使用减号『 - 』之外， 你也可以使用如下的方法来取得前面两个测试的结果：
```shell
[dmtsai@study ~]$ grep -n '[^[:lower:]]oo' regular_express.txt
# 那个 [:lower:] 代表的就是 a-z 的意思！请参考前两小节的说明表格
[dmtsai@study ~]$ grep -n '[[:digit:]]' regular_express.txt
```
## 行首与行尾字符 ^ $
我们在例题一当中，可以查询到一行字符串里面有 the 的，那如果我想要让 the 只在行首列出呢？
这个时候就得要使用制表符了！我们可以这样做：
```shell
[dmtsai@study ~]$ grep -n '^the' regular_express.txt
12:the symbol '*' is represented as start.
```
此时，就只剩下第 12 行，因为只有第 12 行的行首是 the 开头啊～此外， 如果我想要开头是小写字符的那一行就列出呢？可以这样：
```shell
[dmtsai@study ~]$ grep -n '^[a-z]' regular_express.txt
```
 - ! `^`在 [] 内代表『反向选择』，在 [] 之外则代表定位在行首

如果我想要找出来，行尾结束为小数点 (.) 的那一行：
```shell
[dmtsai@study ~]$ grep -n '\.$' regular_express.txt
1:"Open Source" is a good mechanism to develop programs.
2:apple is my favorite food.
3:Football game is not use feet only.
4:this dress doesn't fit me.
10:motorcycle is cheap than car.
11:This window is clear.
12:the symbol '*' is represented as start.
15:You are the best is mean you are the no. 1.
16:The world <Happy> is the same with "glad".
17:I like dog.
18:google is the best tools for search keyword.
20:go! go! Let's go.
```
特别注意到，因为小数点具有其他意义(底下会介绍)，所以必须要使用跳脱字符(\)来加以解除其特殊意义！ 不过，你或许会觉得奇怪，但是第 5~9 行最后面也是 . 啊～怎么无法打印出来？ 这里就牵涉到 Windows 平台的软件对于断行字符的判断问题了！我们使用 cat -A 将第五行拿出来看， 你会发现：
```shell
[dmtsai@study ~]$ cat -An regular_express.txt | head -n 10 | tail -n 6
5 However, this dress is about $ 3183 dollars.^M$
6 GNU is free air not free beer.^M$
7 Her hair is very beauty.^M$
8 I can't finish the test.^M$
9 Oh! The soup taste good.^M$
10 motorcycle is cheap than car.$
```
我们在第九章内谈到过断行字符在 Linux 与 Windows 上的差异，在上面的表格中我们可以发现5~9 行为 Windows 的断行字符 (`^M$`) ，而正常的 Linux 应该仅有第 10 行显示的那样 (`$`) 。所以啰，那个 . 自然就不是紧接在 $ 之前喔！也就捉不到 5~9 行了！

那么如果我想要找出来，哪一行是『空白行』， 也就是说，该行并没有输入任何数据，该如何搜寻？
```
[dmtsai@study ~]$ grep -n '^$' regular_express.txt
```
## 正则表达式与通配符的区别
在第十章 bash 当中，我们知道通配符 `*` 可以用来代表任意(0 或多个)字符， 但是正规表示法并不是通配符，两者之间是不相同的！ 至于正规表示法当中的『 . 』则代表『绝对有一个任意字符』的意思！这两个符号在正规表示法的意义如下：

- `.` (小数点)：代表『一定有一个任意字符』的意思；
- `*` (星星号)：代表『重复前一个字符， 0 到无穷多次』的意思，为组合形态
## 限定连续 `.*` 字符范围 {}
我们可以利用 `.*` 来设定 0 个到无限多个重复字符，那如果我想要限制一个范围区间内的重复字符数呢？举例来说，我想要找出两个到五个 o 的连续字符串，该如何作？
这时候就得要使用到限定范围的字符 {} 了。但因为 { 与 } 的符号在 shell 是有特殊意义的，因此，我们必须要使用跳脱字符 `\` 来让他失去特殊意义才行。至于 {} 的语法是这样的，假设我要找到两个 o 的字符串，可以是：
```shell
[dmtsai@study ~]$ grep -n 'o\{2\}' regular_express.txt
1:"Open Source" is a good mechanism to develop programs.
2:apple is my favorite food.
3:Football game is not use feet only.
9:Oh! The soup taste good.
18:google is the best tools for search keyword.
19:goooooogle yes!

# g 后面接 2 到 5 个 o ，然后再接一个 g 的字符串
[dmtsai@study ~]$ grep -n 'o\{2,5\}' regular_express.txt
# 2个以上
[dmtsai@study ~]$ grep -n 'o\{2,\}' regular_express.txt
```
