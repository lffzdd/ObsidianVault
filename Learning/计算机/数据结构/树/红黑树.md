# 介绍
> 本文由[简悦 SimpRead](http://ksria.com/simpread/) 转码，原文地址 [alrightchiu.github.io](https://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html#why)
### 先備知識與注意事項
在閱讀過 BST 系列文章後可以發現，在 BST 中的操作，不論是 Insert(新增資料) 或是 Delete(刪除資料)，皆需要先做 Search(搜尋)，而 Search(搜尋) 的效率，取決於 BST 的 height(樹高)，如果一棵樹越矮、越平衡 (balanced)，則在此 BST 中搜尋資料的速度較快，理想狀況為 Complete Binary Tree(時間複雜度：$O(\log N)$)。反之，若由於輸入資料的順序使得 BST 沒長好、偏一邊，則在此 BST 中搜尋資料的最壞情況將有可能如同在 Linked List 做搜尋 (時間複雜度：$O(N)$)。
本篇文章將介紹 BST 的進階版 Red Black Tree(RBT，紅黑樹) 之基本性質，會說是進階版，原因在於 RBT 其實也是 BST(滿足 Key(L)<Key(Current)<Key(R))，不過 RBT 的 node 比 BST 多加了「顏色」(紅色或黑色)，而正因為多了「顏色」，便能修正 BST 有可能退化成 Linked list 的潛在缺陷。
![](https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/f1.png?raw=true)
**圖一：不平衡的 BST。**  
另外，本篇文章不具備「RBT 之時間複雜度如何能視同 Complete Binary Tree」之論證 (筆者火侯不夠，請見諒)，建議讀者可以參考 [Introduction to Algorithms，第 13 章](http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844)，不過結論就是，RBT 可以被視為如同 Complete Binary Tree 的 BST，所有與 Search(搜尋) 有關的操作 (Leftmost、Successor、Insert、Delete 等等)，都能夠在 $O(\log N)$內完成。
## 目錄
*   [為什麼需要 Red Black Tree？](#why)
*   [Red Black Tree 的特徵](#rbt)
*   [程式碼](#code)
*   [參考資料](#ref)
*   [RBT 系列文章](#tree_series)
## 為什麼需要 Red Black Tree？
若考慮最壞情況，在建立 BST 時，輸入資料的 Key 恰好被排序過 (例如：$1$、$2$、$3$、$4$...)，那麼這顆 BST 便會退化成 Linked List(例如，所有 leftchild pointer 都指向`NULL`，只有 rightchild child 被使用)：
```
// C++ code
int main{
    BST T;
    T.InsertBST(1);   // 依序加入Key為1、2、3...之資料
    T.InsertBST(2);
    T.InsertBST(3);
    ...
}
```
圖二中，右側的藍色數字表示「搜尋該 node 需要比較 (`if (KEY == current->key)`) 的次數」，也就是迴圈的次數。考慮一串 Linked List 共有 N 個 node，若要尋找第 K 個 node，最壞情況就是一路找到最後一個 node，需要 N 次。
![](https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/f2.png?raw=true)
**圖二：BST 退化成 Linked List。**  
再比較 Complete Binary Tree，如圖三。其中，node 裡的數字即為 Key，node 旁邊的藍色數字代表該 node 在 Complete Binary Tree 中的位置順序，右側的藍色數字代表迴圈次數。  
位置順序與迴圈次數有以下關係：
*   在位置 $2^3=8$與 $2^4=16$之間的 node($2^3\leq i<2^4, i=8\sim 15$)，只需要 $3+1$次比較 (comparison) 即可找到。
*   依此類推，若 BST 中有 N 個 node，則所有 node 保證能夠在$\lfloor {\log N} \rfloor +1$次 ($2^k\leq N<2^{k+1} \iff k\leq\log N$) 迴圈以內找到。
![](https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/f3.png?raw=true)
**圖三：搜尋 BST 的理想情況：Complete Binary Tree。**  
以上兩個範例為一棵具有 N 個 node 的 BST 之 height(樹高) 提供了邊界：$\log N\leq height\leq N$。
因此，BST 越平衡，在樹中搜尋資料的時間就越短，連帶地 Insert(新增資料)、Delete(刪除資料) 也會變得更有效率。
這就是 RBT 值得被介紹的原因。
## Red Black Tree 的特徵
Red Black Tree(RBT) 是 node 塗了「顏色」的 Binary Search Tree(BST)，藉由控制顏色，能夠保證在 RBT 中，**最長 path(路徑) 不會超過最短 path 的兩倍** (若最短的 path 是 $5$，最長的 path 至多只能是 $10$)，如此，RBT 便能夠近似地視為平衡，如圖四。
![](https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/f4.png?raw=true)
**圖四：最短的 path 為 $3$(最右 path:26-41-47)，  
其餘 path 最長只能是 $6$(最左 path:26-17-14-10-7-3)。  
若蓋住`NIL`與顏色，此即為 BST。**  
圖四中，所有原本在 BST 中指向`NULL`的 pointer，在 RBT 中，全部指向了`NIL`。什麼是`NIL`？`NIL`是永遠為黑色、並且實際占有記憶體的 node，因為有配置記憶體，因此能夠以`Node->color`的方式取得某個 node 之顏色 (若使用`NULL`則無法)，這項設計將在後續介紹如何於 RBT 中 Insert(新增資料) 與 Delete(刪除資料) 時派上用場。
接著來看 RBT 的五項特徵：
1.  RBT 中的每一個 node 不是黑色就是紅色。
2.  `root`一定是黑色。
3.  每一個 leaf node(也就是`NIL`) 一定是黑色。
4.  如果某個 node 是紅色，那麼其兩個 child 必定是黑色，不能有兩個紅色 node 相連，如圖四中的 node(17)、node(30)。
    *   若某個 node 為黑色，其 child 之顏色沒有限制，如圖四中的 node(38)、node(26)、node(21)。
5.  站在任何一個 node 上，所有從該 node 走到其任意 descendant leaf 的 path 上之黑色 node 數必定相同。  
根據上述特徵的第四點與第五點，RBT 中 path 可能的長度最小值一定是全部 node 皆為黑色 (如圖四最右 path)，而 path 可能的長度最大值並定是紅色 - 黑色相間 (如圖四最左 path)，如此便確保 RBT 擁有**最長 path(路徑) 不會超過最短 path 的兩倍**的特性。
## 程式碼
實際的程式實現上，會把所有`NIL`視為同一個`NIL`，並把`root`的 parent 指向`NIL`，以節省記憶體空間，如圖五。
![](https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/f5.png?raw=true)
**圖五：。**  
`class TreeNode`與`class RBT`之資料成員 (data member) 程式範例如下：
```cpp
// C++ code
#include <iostream>
#include <string>
class RBT;
class TreeNode{
private:
    TreeNode *leftchild;
    TreeNode *rightchild;
    TreeNode *parent;
    std::string element;
    int key;
    int color;         // 0: Red, 1: Black; using type:bool is ok
    friend RBT;
    ...
}
class RBT{
private:
    TreeNode *root;
    TreeNode *neel;    // 此即為NIL, 常被稱為sentinel
    ...
}
```
(為了避開某些 IDE 將`NIL`設定成保留關鍵字 (reserved keywords，例如`template`、`while`、`struct`等等)，因此使用`neel`。)
為求畫面簡潔，往後的篇幅裡將把 RBT 示意圖中的`NIL`隱藏起來，只顯示 RBT 中的 internal node，如圖六，不過心裡要記得，RBT 無時無刻都被`NIL`充滿著。
![](https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/f6.png?raw=true)
**圖六：。**  
以上便是 RBT 之初探，最重要的結論：就時間複雜度而言，RBT 能夠被視為平衡的 BST，所有操作皆能在時間複雜度為 $O(\log N)$內完成。
在接下來的三篇文章中，將依序介紹 Rotation(旋轉)、Insert(新增資料) 與 Delete(刪除資料)。
### 參考資料：
*   [Introduction to Algorithms, Ch13](http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844)
*   [Fundamentals of Data Structures in C++, Ch10](http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376)
*   [GeeksforGeeks：Red Black Tree](http://code.geeksforgeeks.org/NtLnIk)
### RBT 系列文章
[Red Black Tree: Intro(簡介)](http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html)  
[Red Black Tree: Rotation(旋轉)](http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html)  
[Red Black Tree: Insert(新增資料) 與 Fixup(修正)](http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html)  
[Red Black Tree: Delete(刪除資料) 與 Fixup(修正)](http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html)
回到目錄：
[目錄：演算法與資料結構](http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html)
# 插入
[Red Black Tree: Insert(新增資料)與Fixup(修正)](https://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html)
要修正的有三种情况,
1. Case1：`uncle` 是紅色，不論新增的node是左孩子还是右孩子;
2. Case2：`uncle` 是黑色，而且新增的node為左孩子(LL)；
3. Case3：`uncle` 是黑色，而且新增的node為的左孩子(LR)。
这里不是说只有三种情况, 而是所有的情况都是三种 case 组合起来的
### Uncle 是红色时:
![[Pasted image 20250406125433.png]]
1. 父亲和叔叔涂黑
2. 爷爷涂红即可
3. **同时 Current 指针执行爷爷**

W 节点和 Z 可能又出现了红红的情况, 此时进入下一次的 case
### Uncle 是黑色, 且新增节点为左孩子
![[Pasted image 20250406130100.png]]
左图是新增节点的情况, 右图是由上一次 case 导致的情况
![[Pasted image 20250406130622.png]]
1. 父亲涂黑
2. 爷爷涂红
3. 爷爷右旋 (记住右旋是找左孩子的右节点, 见 `BST`)
```ad-seealso
title: 叔叔非`NIL`
collapse: closed

![[Pasted image 20250406130847.png]]
```
### Uncle 是黑色, 且新增节点为右孩子
![[Pasted image 20250406131135.png]]
很简单, 将 Current 指针指向父亲, 然后做一次左旋:
![[Pasted image 20250406131326.png]]
就变成了 case 2
### 总结
- ~ 综上, 基本都是自己为红, 于是将父叔辈涂黑, 爷爷涂红 (但是 Current 要指向爷爷)
- Case 2 叔叔本来就黑, 就只要将父亲涂黑, 爷爷涂红, 然后对爷爷做一次右旋
- Case 3 先把 Current 变为父亲, 然后左旋, 就成了 case 2
- ==Case 2 除了涂色外类似 LL, 右旋一次, case 3 类似 LR, 除了涂色先左旋再右旋==
- & 这些方法不仅保持结构正确, 还调整了树的平衡性
- @ (图中的 case 2 和 case 3 反了) ![[Pasted image 20250406132216.png]]

上面的 case 的新节点都是叔叔在右边, 实际叔叔可能在左边, 对应了 RR 和 RL 的情况: ![[Pasted image 20250406132523.png]]
```cpp
// C++ code
void RBT::InsertFixedUpRBT(TreeNode *current){

    // case0: parent是黑色, 就不用進回圈
    while (current->parent->color == 0) {   // 若parent是紅色即進入迴圈

        // 上半部：parent是grandparent的left child
        if (current->parent == current->parent->parent->leftchild) { 
            TreeNode *uncle = current->parent->parent->rightchild;
            // case1: 若uncle是紅色
            if (uncle->color == 0) {
                current->parent->color = 1;
                uncle->color = 1;
                current->parent->parent->color = 0;              //grandparent改成紅色
                current = current->parent->parent;
            }
            // case2 & 3: uncle是黑色
            else {  
                if (current == current->parent->rightchild){     // case2
                    current = current->parent;
                    LeftRotation(current);
                }
                // case3
                current->parent->color = 1;                      //把parent塗黑
                current->parent->parent->color = 0;              // grandparent塗紅
                RightRotation(current->parent->parent);
            }
        }
        // 下半部：parent是grandparent的right child, 與上半部對稱
        else {  
            TreeNode *uncle = current->parent->parent->leftchild;
            // case1: 若uncle是紅色
            if (uncle->color == 0) {
                current->parent->color = 1;
                uncle->color = 1;
                current->parent->parent->color = 0;              //grandparent改成紅色
                current = current->parent->parent;
            }
            // case2 & 3: uncle是黑色
            else {
                if (current == current->parent->leftchild) {     // case2
                    current = current->parent;
                    RightRotation(current);
                }
                // case3
                current->parent->color = 1;
                current->parent->parent->color = 0;
                LeftRotation(current->parent->parent);
            }
        }
    }
    root->color = 1;    // 確保root是黑色
}
```