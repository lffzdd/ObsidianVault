##### 二叉查找树
将数据从小到大排列时可以采用二分查找, 效率为 $\log(n)$
但是插入和删除时要遍历, 效率为 $n$, 从而引入了二叉查找树这种结构
>[平衡二叉树(AVL树)哔哩哔哩bilibili](https://www.bilibili.com/video/BV1tZ421q72h?vd_source=56499cc54ebd02db0ac739e485d74801&spm_id_from=333.788.videopod.sections)
# 平衡树和二叉平衡树
但是二叉查找树平衡性越差, 查找效率越低, 于是引入了平衡树和二叉平衡树的概念
## 左旋和右旋操作
![[Pasted image 20250406115658.png]]
1. **确定旋转节点与右子节点**  
   - 设当前节点为 **x**，其右子节点为 **y**（即 `y = x->right`）  
   - **必须条件**：x 必须存在右子节点（否则无法左旋）
2. **调整 x 的右子指针**  
   ```cpp
   x->right = y->left;  // 将 y 的左子树转移给 x 的右子树
   ```
   - 若 y 的左子树非空，需更新其父指针指向 x：
     ```cpp
     if (y->left != nullptr) {
         y->left->parent = x;}
     ```
3. **更新 y 的父指针**  
   ```cpp
   y->parent = x->parent;  // y 继承 x 的父节点
   ```
   - 若 x 是根节点：
     ```cpp
     if (x->parent == nullptr) {
         root = y;}  // 更新根节点为 y
     ```
4. **调整父节点的子指针**  
   - 根据 x 在原父节点中的位置（左/右子节点），将父节点的对应子指针指向 y：
     ```cpp
     if (x == x->parent->left) {
         x->parent->left = y;
     } else {
         x->parent->right = y;
     }
     ```
5. **完成左旋连接**  
   ```cpp
   y->left = x;         // 将 x 设为 y 的左子节点
   x->parent = y;       // 更新 x 的父节点为 y
   ```
 **左旋示意图**
```
初始状态             → 左旋后状态
     x                  y
    / \                / \
   A   y      →       x   C
      / \            / \
     B   C          A   B
```
- **关键变化**：  
  - y 成为新的父节点，x 成为 y 的左子节点  
  - y 的原左子树 B 转移给 x 的右子树  
 **左旋的意义**
1. **降低树高**：将右侧较重的子树向左侧平衡，减少树的高度差异（对平衡树如AVL/红黑树尤为重要）。
2. **维护性质**：在平衡树中，左旋用于修复因插入/删除导致的平衡因子或颜色规则破坏。
3. **时间复杂度**：单次左旋操作仅需 \[O(1)\] 时间。
 **代码实现要点**
```cpp
void leftRotate(Node* x) {
    Node* y = x->right;      // 步骤1：获取右子节点 y
    x->right = y->left;      // 步骤2：转移 y 的左子树到 x
    if (y->left != nullptr) {
        y->left->parent = x; // 步骤2附加：更新父指针
    }
    y->parent = x->parent;   // 步骤3：继承父节点
    if (x->parent == nullptr) {
        root = y;            // 步骤3附加：处理根节点
    } else if (x == x->parent->left) {
        x->parent->left = y;  // 步骤4：调整父节点的左子指针
    } else {
        x->parent->right = y; // 步骤4：调整父节点的右子指针
    }
    y->left = x;             // 步骤5：完成连接
    x->parent = y;
}
```
**与右旋的关系**
- **对称性**：左旋与右旋互为镜像操作，右旋通过操作左子节点对称调整树结构。
- **平衡策略**：实际应用中需根据树的不平衡方向选择左旋或右旋组合操作（如双旋转）。
## 失衡情况
![[Pasted image 20250406120336.png]]
##### 2-3 树
但是二叉平衡树 (AVL 树) 在插入和删除时的旋转操作浪费效率, 于是引入了 2-3 树
 [高中資訊教師黃建庭的教學網站 - 2-3-Tree、2-3-4-Tree與B-Tree](https://sites.google.com/view/zsgititit/home/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-%E4%BD%BF%E7%94%A8python/2-3-tree2-3-4-tree%E8%88%87b-tree) 
2-3 树插入时有从下往上遍历的操作, 比较麻烦, 于是引入了 2-3-4 树,
2-3 树插入时要先从上往下找到插入的位置, 再从下往上调整
2-3-4 树改善了从下往上调整的步骤, 在从上往下查找插入位置的同时, 提前调整了位置, 防止找到位置后再从下往上调整
###### 删除
2-3 树的删除有*旋转*和*合并*的动作, 旋转就是借, 合并会合并父节点及兄弟节点
##### 2-3-4 树
>新增元素到2-3-4-Tree时，如果超过节点元素的最大上限，则中间元素往上提，并入上一层节点，如果在根节点（root）发生超过最大上限的元素个数，则树的高度增加1。非根节点的上层节点已达最大上限的元素个数，则继续往上并入上一层节点，如此会产生由下往上的走访
>如果要避免这个问题，可以由上往下找寻插入节点的位置时，将搜寻过程中经过的所有节点，如果键值个数达到最大上限的节点，先进行分割往上提，让上层都未达最大上限的键值个数，如此新增节点到2-3-4-Tree时，是由上往下找到插入的位置，避免接着由下往上的走访。
###### 删除
分为叶子结点和非叶子结点