> [YOLOv11 | 一文带你深入理解ultralytics最新作品yolov11的创新 | 训练、推理、验证、导出 （附网络结构图）-CSDN博客](https://blog.csdn.net/java1314777/article/details/142665078)
![[Pasted image 20241022120019.png]]
# Bottleneck

1. **层次结构**：Bottleneck 结构通常包括三个卷积层。在输入特征图通过一个小的卷积（通常是 1x1 卷积）进行降维处理后，再通过一个标准的卷积层进行特征提取，最后通过另一个 1x1 卷积进行升维。
   - **降低维度**：第一个 1x1 卷积层用于将输入特征图的通道数压缩到较小的数量，这有助于减少计算的复杂度。
   - **特征提取**：==中间的卷积层负责提取特征，通常使用更大的卷积核==（如 3x3）。
   - **恢复维度**：最后一个 1x1 卷积层用于恢复通道数，以便输出和输入的形状相同。
2. **残差连接**：Bottleneck 结构常配合残差连接（skip connection）使用，即将输入直接添加到输出，这样可以减少深层网络中训练的难度，帮助保持信息的流通。
3. **优点**：
   - **高效性**：通过降低维度，Bottleneck 结构可以显著减少计算量和参数数量，使得网络更高效。
   - **训练更深的网络**：使得更深的网络架构可行，通过残差连接帮助缓解梯度消失问题。
![[Pasted image 20241022115728.png]]
Yolo 中的 `bottleneck` 只有两个 conv 层, 我猜中间通道数可能没变, 或者在进入第二层时同时减少通道数和使用更大的卷积核
```ad-lem
title: yolo中的改动
collapse: closed
在 YOLO 的结构图中，Bottleneck 模块中的 `shortcut=?` 表示是否使用快捷连接（shortcut connection）。这是指在残差网络中常见的连接方式，用于将输入直接添加到输出，以帮助信息流动和梯度传递。

### 具体含义

- **有快捷连接**：如果 `shortcut` 被设置为启用，输入特征会直接与经过卷积处理后的特征相加。这种方式有助于缓解梯度消失问题，并提高网络的训练效率。

- **无快捷连接**：如果 `shortcut` 被设置为禁用，则输入特征不会直接添加到输出。这种情况下，Bottleneck 模块仅通过卷积层进行特征变换。

### 作用

- **信息保留**：快捷连接可以保留输入特征的信息，使得网络在深层次上仍能保持对原始输入的敏感性。

- **梯度传递**：通过直接连接输入和输出，梯度可以更有效地传递到前面的层，促进网络的训练。

- **灵活性**：根据具体任务的需求，设计者可以选择是否启用快捷连接，以优化模型的性能。


```

# `c3k2`
这是 YOLOv 11 中的 `c3k` 和 `c3k2`
![[Pasted image 20241022121314.png]]
这是 yolov 8 的 `c2f`
![[Pasted image 20241022122126.png]]

可以看出, `c3k` 只是两个 conv 变成了三个, 
`c3k2` 是对 `c3k` 进行了包装而 ` c3k2 ` 的 conv 和 ` c2f ` 的一样是两个, 只是中间的 ` bottleneck ` 变成了 ` c3k `, 之所以叫 `c3k2` 而不是 `c2k`, 我猜是因为要突出这个是对 `c3k` 的包装, 
总的来说, 对 `c2f` 进行了更改, 其中的 bottleneck 改成了新的 `c3k`
而 `c2f` 就是改进的 `csp`, `csp` 是分成两半一半用来做拼接连接, 一半用来做加法连接, `c2f` 是对加法连接的过程做了处理, 中间用了多个 `bottleneck` 加法连接块代替了原本的加法连接
# `C2PSA`
![[Pasted image 20241024162612.png]]
`c2` 是 `c2f` 的前身, `c2f` 就是 `c2 with fusion`, 它没有沿通道数切分
`yolov11` 提出了 `c2PSA` 机制, 其实就是把 `c2` 中含的 `bottleneck` 加了一个多头注意力机制
# `DWConv`
原先的解耦头中的分类检测头增加了两个DWConv
![[Pasted image 20241024164942.png]]
**`DWConv` 代表 Depthwise Convolution（深度卷积）**,**深度卷积**将输入的每个通道单独处理，即**每个通道都有自己的卷积核进行卷积**，不与其他通道进行交互。

| 操作类型         | 卷积核大小   | 输入通道数  | 输出通道数   | 参数量                    |
| ------------ | ------- | ------ | ------- | ---------------------- |
| 标准卷积         | `h × w` | `C_in` | `C_out` | `C_in * C_out * h * w` |
| 深度卷积（DWConv） | `h × w` | `C_in` | `C_in`  | `C_in * h * w`         |
为了弥补深度卷积缺乏跨通道信息整合的问题，通常深度卷积后会配合 1 x 1 的点卷积（Pointwise Convolution）使用，通过 1 x 1 的卷积核整合跨通道的信息。这种组合被称为深度可分离卷积（Depthwise Separable Convolution） | 这也是我们本文 YOLOv 11 中的做法。
# 深度和宽度的变化
YOLOv11和YOLOv8还有一个不同的点就是其各个版本的模型（N - S - M - L - X）网络深度和宽度变了
![[Pasted image 20241024165343.png]]
>可以看到在深度（depth）和宽度 （width）两个地方YOLOv8和YOLOv11是基本上完全不同了，这里我理解这么做的含义就是模型网络变小了，所以需要加深一些模型的放缩倍数来弥补模型之前丧失的能力从而来达到一个平衡。
>*本章总结*： YOLOv 11 的改进点其实并不多更多的都是一些小的结构上的创新，相对于之前的 YOLOv 5 到 YOLOv 8 的创新，其实 YOLOv 11 的创新点不算多，但是其是 ultralytics 公司的出品，同时 ultralytics 仓库的使用量是非常多的（不像 YOLOv 9 和 YOLOv 10）所以在未来的很长一段时间内其实 YOLO 系列估计不会再更新了，YOLOv 11 作为最新的 SOTA 肯定是十分适合大家来发表论文和创新的。
# 模型训练
上面给大家讲完了网络的创新下面给大家讲一下YOLOv11如何进行训练预测验证等操作。
## 模型参数
**打开ultralytics/cfg/default.yaml文件可以配置模型的参数，**在其中和模型训练有关的参数及其解释如下:

|     | 参数名           | 输入类型                  | 参数解释                                                                              |
| --- | ------------- | --------------------- | --------------------------------------------------------------------------------- |
| 0   | task          | str                   | YOLO 模型的任务选择，选择你是要进行检测、分类等操作                                                      |
| 1   | mode          | str                   | YOLO 模式的选择，选择要进行训练、推理、输出、验证等操作作操作                                                 |
| 2   | model         | str/optional          | 模型的文件，可以是官方的预训练模型，也可以是训练自己模型的yaml文件                                               |
| 3   | data          | str/optional          | 模型的地址，可以是文件的地址，也可以是配置好地址的yaml文件                                                   |
| 4   | epochs        | int                   | 训练的轮次，将你的数据输入到模型里进行训练的次数                                                          |
| 5   | patience      | int                   | 早停机制，当你的模型精度没有改进了就提前停止训练                                                          |
| 6   | batch         | int                   | 我们输入的数据集会分解为多个子集，一次向模型里输入多少个子集                                                    |
| 7   | imgsz         | int/list              | 输入的图片的大小，可以是整数就代表图片尺寸为int\*int，或者list分别代表宽和高\[w，h\]                               |
| 8   | save          | bool                  | 是否保存模型以及预测结果                                                                      |
| 9   | save_period   | int                   | 在训练过程中多少次保存一次模型文件,就是生成的p                                                          |
| 10  | cache         | bool                  | 参数 cache 用于控制是否启用缓存机制。制。存机制。                                                      |
| 11  | device        | int/str/list/optional | GPU设备的选择：cuda device=0 or device=0,1,2,3 or device=cpu                            |
| 12  | workers       | int                   | 工作的线程，Windows系统一定要设置为0否则很可能会引起线程报错                                                |
| 13  | name          | str/optional          | 模型保存的名字，结果会保存到'project/name' 目录下                                                  |
| 14  | exist_ok      | bool                  | 如果模型存在的时候是否进行覆盖操作                                                                 |
| 15  | prepetrained  | bool                  | 参数pretrained用于控制是否使用预训练模型。                                                        |
| 16  | optimizer     | str                   | 优化器的选择choices=[SGD, Adam, Adamax, AdamW, NAdam, RAdam, RMSProp, auto]             |
| 17  | verbose       | bool                  | 用于控制在执行过程中是否输出详细的信息和日志。                                                           |
| 18  | seed          | int                   | 随机数种子，模型中涉及到随机的时候，根据随机数种子进行生成                                                     |
| 19  | deterministic | bool                  | 用于控制是否启用确定性模式，在确定性模式下，算法的执行将变得可重复，即相同的输入将产生相同的输出                                  |
| 20  | single_cls    | bool                  | 是否是单标签训练                                                                          |
| 21  | rect          | bool                  | 当 rect 设置为 True 时，表示启用矩形训练或验证。矩形训练或验证是一种数据处理技术，其中在训练或验证过程中，输入数据会被调整为具有相同宽高比的矩形形状。 |
| 22  | cos_lr        | bool                  | 控制是否使用余弦学习率调度器                                                                    |
| 23  | close_mosaic  | int                   | 控制在最后几个 epochs 中是否禁用马赛克数据增强                                                       |
| 24  | resume        | bool                  | 用于从先前的训练检查点（checkpoint）中恢复模型的训练。                                                  |
| 25  | amp           | bool                  | 用于控制是否进行自动混合精度                                                                    |
| 26  | fraction      | float                 | 用于指定训练数据集的一部分进行训练的比例。默认值为 1.0                                                     |
| 27  | profile       | bool                  | 用于控制是否在训练过程中启用 ONNX 和 TensorRT 的性能分析                                              |
| 28  | freeze        | int/list/optinal      | 用于指定在训练过程中冻结前 n 层或指定层索引的列表，以防止它们的权重更新。这对于迁移学习或特定层的微调很有用。                          |
