---
aliases: 7.2-边缘检测
tags: []
date created: 星期一, 七月 22日 2024, 11:36:29 中午
date modified: 星期一, 七月 22日 2024, 6:40:18 晚上
---

# 边缘检测的原理和实现
边缘检测是图像处理中的一个重要步骤，主要用于识别图像中像素值变化显著的区域，这些区域通常对应于物体的边界。常见的边缘检测算法有 Sobel 算子、Prewitt 算子、Canny 边缘检测等。下面详细介绍这些方法的原理和实现。
## 1. Sobel 算子
### **原理**：
Sobel 算子是一种基于微分的边缘检测方法，利用卷积操作来计算图像梯度的近似值。它使用两个 3x3 的卷积核，一个检测水平方向的变化（Gx），另一个检测垂直方向的变化（Gy）。
#### **实现**：

```python
import cv2
import numpy as np
# 读取灰度图像
image = cv2.imread('image.jpg', cv2.IMREAD_GRAYSCALE)
# 使用Sobel算子计算梯度
sobel_x = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=3) # 水平梯度
sobel_y = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=3) # 垂直梯度
# 计算梯度的幅值
gradient_magnitude = np.sqrt(sobel_x**2 + sobel_y**2)
# 显示结果
cv2.imshow('Sobel Edge Detection', gradient_magnitude)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

## 2. Prewitt 算子
### **原理**：
Prewitt 算子和 Sobel 算子类似，但它的卷积核稍微不同。Prewitt 算子的卷积核更简单，因此计算速度可能稍快，但在噪声处理上不如 Sobel 算子。
#### **实现**：

```python
# 定义Prewitt卷积核
prewitt_x = np.array([[1, 0, -1], [1, 0, -1], [1, 0, -1]])
prewitt_y = np.array([[1, 1, 1], [0, 0, 0], [-1, -1, -1]])
# 使用Prewitt算子计算梯度
prewitt_x_gradient = cv2.filter2D(image, -1, prewitt_x)
prewitt_y_gradient = cv2.filter2D(image, -1, prewitt_y)
# 计算梯度的幅值
gradient_magnitude_prewitt = np.sqrt(prewitt_x_gradient**2 + prewitt_y_gradient**2)
# 显示结果
cv2.imshow('Prewitt Edge Detection', gradient_magnitude_prewitt)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

## 3. Canny 边缘检测
### **原理**：
Canny 边缘检测是一种多阶段的边缘检测算法，具有较高的准确性和鲁棒性。它包括以下步骤：
1. 高斯滤波：平滑图像，减少噪声。
2. 计算梯度：使用 Sobel 算子计算图像的梯度幅值和方向。
3. 非极大值抑制：细化边缘，去除非边缘点。
4. 双阈值检测：检测强边缘和弱边缘。
5. 边缘连接：通过连接强边缘和弱边缘，最终确定边缘。
#### **实现**：

```python
# 使用Canny边缘检测
edges = cv2.Canny(image, 100, 200)
# 显示结果
cv2.imshow('Canny Edge Detection', edges)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

## 总结
边缘检测是图像分割和特征提取中的重要步骤，不同的边缘检测方法有各自的优缺点。Sobel 和 Prewitt 算子实现简单，适用于基本的边缘检测任务；而 Canny 边缘检测由于其多阶段处理，能更好地平衡检测的准确性和鲁棒性，适用于更复杂的图像处理任务。
# Sobel 算子
## Sobel 算子的原理详解
Sobel 算子是一种用于边缘检测的微分算子，能够检测图像中灰度值的变化，进而识别出边缘。Sobel 算子的基本思想是通过卷积操作来计算图像在水平方向和垂直方向的梯度。
### 数学原理
1. **梯度计算**：
   Sobel 算子使用两个 3x3 的卷积核来分别计算图像在 x 方向和 y 方向的梯度。卷积核如下：
   $$
   G_x = \begin{bmatrix}
   -1 & 0 & 1 \\
   -2 & 0 & 2 \\
   -1 & 0 & 1
   \end{bmatrix}, \quad
   G_y = \begin{bmatrix}
   -1 & -2 & -1 \\
   0 & 0 & 0 \\
   1 & 2 & 1
   \end{bmatrix}
   $$
   - $G_x$ 用于检测水平方向的梯度变化。
   - $G_y$ 用于检测垂直方向的梯度变化。
- ~ $G_x$ 扫出垂直边缘 ![[Pasted image 20240722142534.png]]

2. **卷积操作**：
   对于每个像素位置 (i, j)，梯度计算如下：
   $$
   \text{梯度值} = G_x * I + G_y * I
   $$
   其中，$*$ 表示卷积操作，$I$ 表示原始图像。具体计算方式为：
   $$
   G_x(i,j) = \sum_{k=-1}^{1} \sum_{l=-1}^{1} G_x(k,l) \cdot I(i+k, j+l)
   $$
   $$
   G_y(i,j) = \sum_{k=-1}^{1} \sum_{l=-1}^{1} G_y(k,l) \cdot I(i+k, j+l)
   $$
3. **梯度幅值和方向**：
   计算完 x 和 y 方向的梯度后，可以得到梯度的幅值和方向：
   $$
   M(i,j) = \sqrt{G_x(i,j)^2 + G_y(i,j)^2}
   $$
   $$
   \theta(i,j) = \arctan\left(\frac{G_y(i,j)}{G_x(i,j)}\right)
   $$
   其中，$ M(i,j) $ 表示梯度幅值，$ \theta(i,j) $ 表示梯度方向。
### 实现步骤
1. **读取图像并转换为灰度图**：

   ```python
   import cv2
   import numpy as np
   image = cv2.imread('image.jpg', cv2.IMREAD_GRAYSCALE)
   ```

2. **应用 Sobel 算子计算梯度**：

   ```python
   sobel_x = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=3)
   sobel_y = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=3)
   ```

3. **计算梯度幅值**：

   ```python
   gradient_magnitude = np.sqrt(sobel_x**2 + sobel_y**2)
   ```

4. **显示结果**：

   ```python
   cv2.imshow('Sobel Edge Detection', gradient_magnitude)
   cv2.waitKey(0)
   cv2.destroyAllWindows()
   ```

## 举例说明
我们来计算给定矩阵的水平和垂直边缘矩阵。我们将使用 Sobel 算子来进行计算。为了进行卷积操作，我们需要对图像进行填充（padding）。在这里，我们采用零填充（zero padding）。
### 原始矩阵
$$
\begin{bmatrix}
  12 & 90 & 89 & 86 & 87 & 82 \\
  10 & 12 & 88 & 85 & 83 & 84 \\
  9 & 15 & 12 & 84 & 84 & 88 \\
  12 & 14 & 10 & 82 & 88 & 89 \\
  11 & 17 & 16 & 12 & 88 & 90 \\
  10 & 16 & 15 & 17 & 89 & 88
\end{bmatrix}
$$
### 填充后的矩阵
在矩阵的四周进行零填充，得到：
$$
\begin{bmatrix}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  0 & 12 & 90 & 89 & 86 & 87 & 82 & 0 \\
  0 & 10 & 12 & 88 & 85 & 83 & 84 & 0 \\
  0 & 9 & 15 & 12 & 84 & 84 & 88 & 0 \\
  0 & 12 & 14 & 10 & 82 & 88 & 89 & 0 \\
  0 & 11 & 17 & 16 & 12 & 88 & 90 & 0 \\
  0 & 10 & 16 & 15 & 17 & 89 & 88 & 0 \\
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix}
$$
### Sobel 算子
$$Gx = \begin{bmatrix}
-1 & 0 & 1 \\
-2 & 0 & 2 \\
-1 & 0 & 1 
\end{bmatrix}$$
$$Gy = \begin{bmatrix}
 1 & 2 & 1 \\
 0 & 0 & 0 \\
-1 &-2 &-1 
\end{bmatrix}$$​
### 计算$Gx$和$Gy$矩阵
我们逐步应用 Sobel 算子来计算每个位置的水平和垂直梯度。
**水平梯度（Gx）矩阵**
$$
\begin{bmatrix}
192 & 232 & 65 & -9 & -9 & -257 \\
129 & 236 & 211 & 60 & -2 & -337 \\
56 & 82 & 279 & 217 & 14 & -339 \\
60 & 4 & 200 & 300 & 96 & -348 \\
64 & 13 & 59 & 296 & 234 & -353 \\
49 & 15 & -3 & 220 & 220 & -266 \\
\end{bmatrix}
$$
**垂直梯度（Gy）矩阵**
$$
\begin{bmatrix}
  32 & 122 & 273 & 341 & 335 & 251 \\
  -81 & -230 & -231 & -84 & -2 & 9 \\
  6 & -72 & -157 & -79 & 12 & 15 \\
  6 & 10 & -62 & -136 & -62 & 8 \\
  -2 & 7 & -53 & -124 & -64 & -1 \\
  -39 & -61 & -61 & -128 & -278 & -268
\end{bmatrix}
$$
**梯度幅值（省略小数）**
$$
\begin{bmatrix}
  194 & 262 & 280 & 341 & 335 & 359 \\
  152 & 329 & 312 & 103 & 2 & 337 \\
  56 & 109 & 320 & 230 & 18 & 339 \\
  60 & 10 & 209 & 329 & 114 & 348 \\
  64 & 14 & 79 & 320 & 242 & 353 \\
  62 & 62 & 61 & 254 & 354 & 377
\end{bmatrix}
$$
**梯度方向（单位为度）**
$$
\begin{bmatrix}
  9.46 & 27.74 & 76.61 & -88.49 & -88.46 & -44.32 \\
  -32.12 & -44.26 & -47.59 & -54.46 & 45 & -1.53 \\
  6.12 & -41.28 & -29.37 & -20 & 40.6 & -2.53 \\
  5.71 & 68.2 & -17.22 & -24.39 & -32.86 & -1.32 \\
  -1.79 & 28.3 & -41.93 & -22.73 & -15.3 & 0.16 \\
  -38.52 & -76.18 & 87.18 & -30.19 & -51.64 & 45.21
\end{bmatrix}

$$
### 解释
从上述结果可以看出：

- **Gx 矩阵**主要检测水平边缘。在这段矩阵中，我们可以看到数值在边缘附近发生明显变化。
- **Gy 矩阵**主要检测垂直边缘。在这段矩阵中，垂直边缘的变化较小，因此数值变化不如水平边缘显著。
通过这种方式，我们可以检测出图像中的边缘。
# Q&A
- ? Gx检测出的是不是垂直边缘？
- ~ Gx卷积核主要用于检测图像中的**水平边缘**。它通过对图像进行卷积操作，能够突出显示图像中亮度变化的方向主要是水平方向的区域。在Gx卷积核中，中心的元素（在这个例子中是0）两侧的系数是相反的，这导致在水平方向上相邻像素之间存在较大亮度差异时，卷积结果会有较高的响应。

- ? 不对吧，Gx滑动时，左右两侧亮度差异很大，说明有一侧可能是边缘，这种边缘不是竖向的吗
- ~ 对不起，我之前的解释有误。请允许我更正这一点。
- ~ 在图像处理中，Gx卷积核（如 `-1 0 1` 横向排列的核）实际上是用来检测**水平方向**上的边缘变化的。当Gx卷积核在图像上滑动时，它主要关注每个像素点与其水平相邻像素点之间的亮度差异。如果左右两侧的像素亮度差异很大，那么这通常意味着在该位置存在一条水平边缘。
- ~ 然而，这里的“水平边缘”和“竖向边缘”可能会引起一些混淆。在图像处理中，“水平边缘”是指图像中沿水平方向（即从左到右或从右到左）的亮度变化，而“竖向边缘”则是指沿垂直方向（即从上到下或从下到上）的亮度变化。
- ~ 因此，当Gx卷积核检测到左右两侧像素亮度差异很大时，它检测到的是一条水平方向的边缘，而不是我们通常所说的“竖向边缘”。这里的“竖向”可能是一个误导性的表述，因为它实际上指的是边缘的方向与图像的水平轴垂直，但从视觉上看，这样的边缘仍然是水平延伸的。
- ~ 总结一下，Gx卷积核用于检测图像中的水平边缘，即那些沿水平方向（从左到右或从右到左）具有显著亮度变化的区域。希望这次解释能够更清楚地说明问题。

- ? 也就是说，水平边缘实际上是水平方向上看存在的边缘，这种边缘实际上是竖向的
- ~ 是的，您的理解是正确的。在图像处理中，当我们谈论“水平边缘”时，我们实际上是指那些在图像的水平方向上（即从左到右或从右到左）具有显著亮度变化的边缘。尽管这些边缘在视觉上是沿水平方向延伸的，但从数学和技术的角度来看，它们描述了图像中像素值在水平方向上的突变。
- ~ 然而，这种表述可能会让人有些困惑，因为“水平边缘”这个词组中的“水平”一词似乎指的是边缘的方向，而实际上它描述的是边缘检测时关注的像素变化方向（即水平相邻像素之间的亮度差异）。相反，边缘本身的走向（无论是向上、向下、向左还是向右）取决于亮度变化的具体情况。
- ~ 为了更清晰地表达，我们可以说Gx卷积核检测的是那些在水平扫描线上（即图像的一行）上具有显著亮度变化的边缘。这些边缘可能是由物体之间的边界、阴影、光照变化等因素造成的。当Gx卷积核在图像上滑动时，它会计算每个像素点与其左右相邻像素点之间的亮度差异，并将这些差异累积起来以形成边缘的响应。如果某个位置的响应值很高，那么通常意味着在该位置存在一条水平方向的边缘。
- ~ 需要注意的是，这里的“水平方向”是相对于图像的行和列而言的，而不是相对于图像的物理方向或观察者的视角而言的。因此，在查看图像处理结果时，我们需要根据图像的布局和像素的排列方式来理解边缘的方向。
