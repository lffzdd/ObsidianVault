I/O 多路复用（I/O Multiplexing）是 **并发服务器最重要的 I/O 处理模型之一**，特别适用于 **同时处理多个 I/O 连接** 的情况，例如 Web 服务器、数据库服务器、聊天服务器等。
你可以把 **I/O 多路复用** 想象成 **一个高效的"管家"**，负责同时监视多个 I/O 事件，而不是让每个 I/O 连接都创建一个独立的进程或线程。
## **1. 为什么需要 I/O 多路复用？**
我们已经学习了 **阻塞 I/O、非阻塞 I/O、信号驱动 I/O 和异步 I/O**，那么 **为什么还要 I/O 多路复用呢？**
考虑一个 **并发服务器**（如 Web 服务器）：
- **进程/线程并发模型**
    - 传统方法是 **每个客户端连接分配一个进程或线程**，但这样 **创建和销毁进程/线程的开销大**，而且**线程数量太多会导致系统崩溃**。
- **非阻塞 I/O**
    - 服务器可以用 **非阻塞模式** 处理多个连接，但需要反复轮询（不断调用 `read()` ），浪费 CPU 资源。
- **信号驱动 I/O**
    - 服务器可以用 **信号驱动模式**，但信号处理过于复杂，不适用于所有类型的 I/O。
**👉 有没有更高效的方法？**  
答案就是 **I/O 多路复用**！
## **2. I/O 多路复用的核心思想**
I/O 多路复用的核心思想是：
> **"用一个线程就能同时监听多个 I/O 事件，当某个 I/O 设备准备好时，内核通知进程，而不是进程不断轮询。"**
👉 **关键点**：
- 进程/线程只需要 **等待一个"事件列表"**，而不是每个 I/O 设备都创建一个线程。
- **内核负责监听多个 I/O 事件，并在有数据可读/可写时通知进程**，避免进程/线程不断轮询，节省 CPU 资源。
**🚀 这就是 `select()`、`poll()` 和 `epoll()` 的核心作用！**
---
## **3. I/O 多路复用的实现方式**
I/O 多路复用在 Linux 中有 **三种主要实现方式**：
1. **`select()`**
2. **`poll()`**
3. **`epoll()`（现代高性能方式）**
---
### **(1) `select()`**
`select()` 是最早的 I/O 多路复用接口，使用 **一个"文件描述符集合"** 来监听多个 I/O 事件。
#### **💡 `select()` 工作原理**
1. 进程调用 `select()`，告诉内核 **要监视哪些文件描述符**（即哪些 I/O 连接）。
2. 内核会 **阻塞进程，监听所有 I/O 事件**。
3. 一旦某个文件描述符有 I/O 事件（如可读/可写），`select()` 立即返回，进程开始处理数据。
#### **🚀 `select()` 的优缺点**
✅ **优点**：
- 让进程可以**同时监听多个 I/O 事件**，不需要创建多个进程/线程。
- 兼容性好，几乎所有操作系统都支持。
❌ **缺点**：
- **最多只能监听 1024 个文件描述符**（受 `FD_SETSIZE` 限制）。
- **每次都要传递整个文件描述符集合到内核**，导致**性能低**。
- **时间复杂度 O(n)**，当监视的 I/O 连接数变多时，性能下降。
---
### **(2) `poll()`**
`poll()` 也是 I/O 多路复用接口，和 `select()` 类似，但有一些改进。
#### **💡 `poll()` 工作原理**
- `poll()` 用 **`pollfd` 结构数组** 取代 `select()` 的 **"文件描述符集合"**，所以没有 `FD_SETSIZE` 限制。
- 进程调用 `poll()`，内核检查哪些 I/O 事件就绪，然后返回。
#### **🚀 `poll()` 的优缺点**
✅ **优点**：
- **可以监听任意数量的文件描述符**，没有 1024 的限制。
- 代码比 `select()` 更清晰。
❌ **缺点**：
- **每次调用都要遍历整个文件描述符数组，时间复杂度 O(n)**，效率仍然不高。
---
### **(3) `epoll()`**
`epoll()` 是 **Linux 专门优化高并发 I/O 的解决方案**，比 `select()` 和 `poll()` 更高效。
#### **💡 `epoll()` 工作原理**
- `epoll_create()` 创建 **"事件表"**，并返回一个 `epoll` 句柄。
- `epoll_ctl()` **向事件表中添加/删除文件描述符**（即监听哪些 I/O 事件）。
- `epoll_wait()` **阻塞等待**，直到有 I/O 事件就绪，才返回事件列表。
#### **🚀 `epoll()` 的优缺点**
✅ **优点**：
- **时间复杂度 O(1)**（不需要遍历整个文件描述符列表）。
- **没有文件描述符数量限制**，可以监听几万个连接！
- **事件触发模式**，只有发生变化的 I/O 事件才会通知进程，避免无意义的轮询。
❌ **缺点**：
- 只能在 **Linux** 使用（Windows 和 macOS 不支持）。
- **代码稍微复杂**，但性能远超 `select()` 和 `poll()`。
---
## **4. `select()` vs `poll()` vs `epoll()`**
|方式|最大连接数|是否遍历所有连接|适用场景|
|---|---|---|---|
|`select()`|1024（受 `FD_SETSIZE` 限制）|是（O(n)）|小规模并发|
|`poll()`|无限制|是（O(n)）|中等规模并发|
|`epoll()`|无限制|否（O(1)）|**大规模并发**（高性能服务器）|

## **5. I/O 多路复用的应用场景**
📌 **什么时候该用 I/O 多路复用？**
1. **高并发服务器**
    - Web 服务器（如 Nginx）
    - 数据库服务器（如 MySQL）
    - 代理服务器（如 Squid）
2. **需要同时管理多个 I/O 连接**
    - 即时聊天服务器（如 WhatsApp、微信）
    - 网络游戏服务器
    - 视频流媒体服务器
3. **当 I/O 操作时间不确定时**
    - 多个慢速 I/O 设备（磁盘、网络等）
    - 异步任务队列（消息队列、Redis）
---
## **6. 结论**
### **🚀 I/O 多路复用的本质**
> **"让单个线程管理多个 I/O 连接，避免创建大量进程/线程，提高服务器吞吐量。"**

👉 `select()` 和 `poll()` **适用于小型/中型并发**，但性能不佳。  
👉 `epoll()` **是现代高并发服务器的最佳选择**，如 Nginx、Redis、MySQL 都用它处理高并发 I/O。
### **✅ 总结**
🔹 **I/O 多路复用的作用** → 让一个线程高效监听多个 I/O 事件。  
🔹 **`select()`** → 低效，有 1024 限制。  
🔹 **`poll()`** → 取消了 1024 限制，但仍然 O(n)。  
🔹 **`epoll()`** → O(1) 级性能，适用于 **高并发服务器**，如 Nginx、Redis、MySQL。
### **⏭️ 接下来你可以学习**
1. **代码示例**（如何用 `select()`、`poll()`、`epoll()` 写服务器）。
2. **Nginx 如何用 `epoll()` 提高性能**。
3. **深入理解 `epoll_wait()` 和 `Epoll Edge-Triggered` 模式（ET 模式）**。
你想先学哪部分？😃