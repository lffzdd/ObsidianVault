---
aliases: 数据表示
tags: []
date created: Monday, November 18th 2024, 10:56:17 pm
date modified: Tuesday, November 19th 2024, 7:05:36 pm
---
`size_t` 是无符号 32 位, 当它与有符号数相乘时像作用是默认都取无符号,有的时候贸然与有符号数相乘, 若给有符号数赋值为负数, 可能会造成溢出
逻辑移位,算数移位只针对负数补码
# 浮点数
> [Site Unreachable](https://zhuanlan.zhihu.com/p/343049681)
规范化数取值范围:
![[Pasted image 20241119134227.png]]
非规范化数取值范围:
![[Pasted image 20241119134310.png]]
## 浮点数的舍入
浮点数的舍入是计算机科学和数值计算中的一个重要概念，它涉及到如何在进行数值运算时处理浮点数的表示精度和失真。由于浮点数在计算中无法精确表示所有的实数，舍入操作通常是必需的，以确保结果的有效性和稳定性。以下是浮点数舍入的基本概念和方法：
### 1. 舍入的必要性
- **有限精度**：浮点数在计算机中以有限的位数存储，而大多数实数无法被精确表示，因此在计算中可能会出现舍入误差。
- **计算精度**：为了保持计算结果的有效性，必须对浮点数进行舍入，以避免精度的损失和数据的失真。
### 2. 舍入的方式
浮点数的舍入方法有几种常用策略，主要包括：
#### 1. 向零舍入（Truncation）
- **描述**：直接去掉超出精度范围的部分。
- **例子**：对于 3.14159，若需要存储为两位有效数字，则舍入为 3.14。
#### 2. 向最接近的偶数舍入（Round Half to Even）
- **描述**：当数值中间值（即 0.5）的情况下，向最接近的偶数舍入。这种方法可以减少统计误差。
- **例子**：3.5 舍入为 4.0，而 2.5 舍入为 2.0（偶数）。
#### 3. 向上舍入（Round Half Away From Zero）
- **描述**：对于 0.5 和负的 0.5，舍入到距离更远的整数。
- **例子**：3.5 舍入为 4.0，-2.5 则舍入为 -3.0。
#### 4. 向下舍入（Round Down）
- **描述**：始终向下（或左）舍入。对于正数，向零舍入；对于负数，舍入为更大的负数。
- **例子**：3.7 舍入为 3.0，-3.7 舍入为 -4.0。
#### 5. 向上舍入（Round Up）
- **描述**：始终向上（或右）舍入。对于正浮点数，总是到下一个数字；对于负数，向零舍入。
- **例子**：3.1 舍入为 4.0，-3.1 舍入为 -3.0。
### 3. 舍入误差
- 舍入误差是由于浮点数的有限精度而造成的计算误差。在数值计算中，舍入误差可能会影响到最终结果的准确性。
- 长链的算术运算可能会导致误差逐渐累积，从而使最终结果显著偏离真实值。因此，合理选择舍入策略和精度是非常重要的。
### 4. 舍入对算法的影响
- **稳定性**：设计数值算法时，需要考虑舍入误差的影响，确保算法稳健，能够在有限精度下产生准确结果。
- **精度**：舍入方式的选择可能会影响计算的偏差，因此在特定应用中选择合适的舍入方法至关重要。
## 舍入过程
让我们通过一个实际的例子来说明如何在 32 位 IEEE 754 单精度浮点数中实现浮点数的舍入。这个过程将涉及从十进制数到二进制数的转换、标准化、舍入和最终的存储。
### 示例：舍入 33.5 到 IEEE 754 浮点数
我们以**33.5**为例，演示如何将其转换为 32 位浮点数，并进行舍入。
#### 1. 转换为二进制
首先，将**33.5**转换为二进制：
- **整数部分 (33)**：
  - 33 的二进制：100001
- **小数部分 (0.5)**：
  - 0.5 的二进制：0.1
所以，33.5 的二进制表示为：
$$
33.5 = 100001.1_2
$$
#### 2. 规范化
规范化浮点数，为了符合 $(1, 2)$ 的范围，将其表示为：
$$
100001.1 \equiv 1.000011 \times 2^5
$$
- **尾数**（Mantissa）：1.000011
- **指数**（Exponent）：5
#### 3. 存储 7 尾数和偏置
- **偏置**：对于单精度浮点数，偏置为 127，因此实存储指数为：
$$
E_{\text{stored}} = E + \text{bias} = 5 + 127 = 132
$$
- **存储的二进制表示**：
  - 132 的二进制表示是：10000100
#### 4. 表达尾数
- 在 IEEE 754 表示法中，尾数去掉前导的 "1"，只存储后面的部分，因此尾数（Mantissa）为：
  - 从 1.000011 中去掉 1，得到 000011，补足 23 位为：
    - 00001100000000000000000（补 0 至 23 位）
### 5. 组合成 IEEE 754 单精度浮点数
将符号位、指数部分和尾数部分组合：
- **符号位**：正数，所以为 0
- **指数位**：10000100
- **尾数位**：00001100000000000000000
最终得到的 32 位浮点数表示为：
$$
0 \quad 10000100 \quad 00001100000000000000000
$$
### 6. 舍入过程
在浮点数运算中，如果在某些情况下得到的结果在尾数部分需要额外的舍入，假设我们进行的操作是**33.5 + 0.3**，而浮点数英特尔实现的结果不得不舍入到最近的可表示数。
例如，假设计算后得到临时的尾数为：
$$
1.00001100011001100110011…
$$
在这种情况下，舍入的步骤如下：
- 首先决定最接近的可表示数，比较小数部分。根据 IEEE 754 向最近的偶数偶数进行舍入。
- 如果小数部分超过 0.5，则向上舍入到：
$$
1.000100
$$
- 更新后的尾数为：00010000000000000000000
### 7. 更新后的存储
将新的尾数和存储值重新组合，得到更新后的 IEEE 754 表示。
### 总结
我们通过将 33.5 转换为 IEEE 754 单精度浮点数展示了舍入的过程，其中涉及到从十进制转换到二进制、规范化、采用偏置存储指数和尾数的过程，以及在扩展数值之后的舍入。通过这种方式，计算机能够确保浮点数在计算过程中的准确性与合理性。
## 浮点数加法
浮点数之间相加的过程可以通过一个具体的例子来说明，涉及到 IEEE 754 单精度浮点数表示法的步骤，包括对齐、相加、舍入等。以下是相加过程的详细步骤。
### 示例：相加两个浮点数
假设我们要相加两个浮点数 **A = 1.5** 和 **B = 2.75**。
#### 1. 转换为 IEEE 754 表示法
首先，将这两个数转换为 IEEE 754 单精度浮点数。
##### 对于 A = 1.5
- **十进制 to 二进制**：
    - 1.5 的二进制表示为 **1.1**。
- **规范化**：
$$
1.1 = 1.1 \times 2^0
$$
- **存储**：
    - 符号位 $S = 0$
    - 指数 $E = 0$
    - 偏置存储：$E_{\text{stored}} = 0 + 127 = 127$ → $01111111_2$
    - 尾数（去掉前导 1 并补足为 23 位）：$10000000000000000000000_2$
因此，1.5 的 IEEE 754 表示为：
$$
0 \quad 01111111 \quad 10000000000000000000000
$$
##### 对于 B = 2.75
- **十进制 to 二进制**：
    - 2.75 的二进制表示为 **10.11**。
- **规范化**：
$$
10.11 = 1.011 \times 2^1
$$
- **存储**：
    - 符号位 $S = 0$
    - 指数 $E = 1$
    - 偏置存储：$E_{\text{stored}} = 1 + 127 = 128$ → $10000000_2$
    - 尾数（去掉前导 1 并补足为 23 位）：$01100000000000000000000_2$
因此，2.75 的 IEEE 754 表示为：
$$
0 \quad 10000000 \quad 01100000000000000000000
$$
### 2. 加法过程
现在我们需要将两个浮点数相加：$A + B$。
- **A**: 0 01111111 10000000000000000000000
- **B**: 0 10000000 01100000000000000000000
#### 步骤 1: 对齐尾数
在执行加法时，我们需要确保两个数的指数对齐。这里，**B**的指数较高（$128$ vs $127$），所以我们需要将**A**的尾数右移并更新其指数，以便对齐。
将 A 的尾数右移一位，同时更新其指数：
- 移动结果：$0.1$
- 新的指数：$127 + 1 = 128$
现在：
- **A**: 0 10000000 01000000000000000000000（对应 1.5）
- **B**: 0 10000000 01100000000000000000000（对应 2.75）
#### 步骤 2: 相加尾数
将对齐后的尾数相加：
$$
01000000000000000000000 + 01100000000000000000000 = 10100000000000000000000
$$
#### 步骤 3: 处理结果
此时，结果是 $1.0100000 \times 2^{128}$。对应的指数仍为$128$，但是尾数需要重新规范化。
规范化得到：
$$
1.0100000 \times 2^{128} = 1.0100000 \times 2^{128} = 10100000000000000000000 
$$
- 结果的尾数为：$01000000000000000000000$
- 更新的指数：$128 + 1 = 129$
#### 步骤 4: 存储
1. 符号位：$0$
2. 存储的指数：
   - $E_{\text{stored}} = 129 + 127 = 256$ → $10000001_2$
3. 尾数（去掉前导 1 并补足为 23 位）：
   - $00000000000000000000000_2$
最终结果：
$$
0 \quad 10000001 \quad 00000000000000000000000
$$
### 3. 结果
将两者相加结果为**4.25** (即 $2.5 + 2.75$)。IEEE 754 表示为：
$$
0 \quad 10000001 \quad 00000000000000000000000
$$
- ! 计算错了, 但是思路看懂就行
## 浮点数减法
**浮点数相减时，确实需要在指数对齐后将尾数位变成补码并转换为加法运算**。以下是浮点数相减的详细步骤：
1. **对阶**：这是浮点数相减的第一步，目的是使两个浮点数的指数（阶码）相等。通常，我们会找出两个浮点数中较小的指数，然后将另一个浮点数的尾数向右移动（即向低位移动）相应的位数，同时将其指数增加相应的值，直到两个浮点数的指数相等。这个过程中可能会产生误差，因为移动尾数会舍弃一些有效位，但这在浮点运算中是常见的。
2. **尾数求和（转换为加法）**：在对阶完成后，我们可以将减法转换为加法。具体来说，就是将较小的浮点数的尾数取反（即变为补码），然后将其与另一个浮点数的尾数相加。这里使用补码的目的是为了简化运算，因为补码可以方便地处理负数。在二进制中，一个数的补码就是将其所有位取反（0变为1，1变为0）后加1。
3. **规格化**：尾数相加后，我们可能需要对结果进行规格化处理。规格化处理是指将结果的指数调整到正确的位置，并将尾数的高位进行截断（或舍入）。这是为了确保结果仍然是一个有效的浮点数。规格化过程中，如果尾数的最高位不是1（对于正数）或0（对于负数），则需要将尾数左移或右移，并相应地调整指数。
4. **舍入**：在对阶和规格化的过程中，可能会丢失一些尾数的低位，这会引起误差。为了减小这种误差，我们需要进行舍入操作。常见的舍入方法有“0舍1入”法（类似于十进制的四舍五入）和恒1法等。舍入操作的目的是在确保精度的前提下，尽可能减小误差。
5. **溢出判断**：最后，我们需要判断结果是否溢出。在浮点运算中，溢出通常发生在指数过大或过小的情况下。如果结果的指数超出了浮点数能表示的范围，则认为发生了溢出。此时，我们可能需要进行特殊处理，如将结果设置为无穷大或抛出异常等。
综上所述，浮点数相减的过程包括了对阶、尾数求和（转换为加法）、规格化、舍入和溢出判断等步骤。这些步骤共同确保了浮点数相减的准确性和有效性。
