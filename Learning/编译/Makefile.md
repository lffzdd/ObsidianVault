# 结构
Makefile 是一种用于自动化构建和管理项目的文件，特别是在软件开发中。它通常与 `make` 工具一起使用，`make` 可以读取 Makefile 中定义的规则和指令，自动化编译和链接程序的过程。Makefile 的主要目的是减少手动编译的工作，确保项目的构建过程高效且一致。
### Makefile 的基本组成部分：
1. **目标 (Target)**：要生成的目标文件，比如可执行文件或库。
2. **依赖 (Dependencies)**：构建目标所需的文件，通常是源代码文件。
3. **命令 (Commands)**：用于构建目标的命令，通常是编译器命令（如 `gcc` 或 `g++`）。
### 简单示例：
```makefile
all: program
program: main.o utils.o
    gcc -o program main.o utils.o
main.o: main.c
    gcc -c main.c
utils.o: utils.c
    gcc -c utils.c
clean:
    rm -f program main.o utils.o
```
### 说明：
- 顶部的 `all` 是一个伪目标，默认情况下会构建 `program`。
- `program` 依赖于 `main.o` 和 `utils.o`，当任一依赖文件更新时，会重新构建。
- `clean` 是另一个伪目标，用于清理生成的文件。
# 正向读取, 反向执行
是的，您理解得非常正确！Makefile 的工作流程就是这样反向执行的。具体来说，步骤如下：
1. **查找目标**：当您运行 `make` 命令时，它会默认寻找 Makefile 中的第一个目标（在我们的示例中是 `all`），然后根据这个目标查找其依赖项。
2. **构建依赖项**：
   - 对 `all` 目标，它依赖于 `program`。
   - 对 `program` 目标，它依赖于两个对象文件 (`main.o` 和 `utils.o`)。
3. **反向执行**：
   - 如果 `main.o` 或 `utils.o` 需要更新（即它们的源文件 `main.c` 或 `utils.c` 比 `.o` 文件更新），`make` 会反向查找依赖。
   - 例如，`make` 会先执行 `gcc -c main.c` 来生成 `main.o`，再执行 `gcc -c utils.c` 来生成 `utils.o`。
4. **链接生成可执行文件**：
   - 一旦所有依赖文件（即 .o 文件）都更新完成，`make` 将执行命令 `gcc -o program main.o utils.o` 来链接这些目标文件，生成最终的可执行文件 `program`。
5. **清理目标**：
   - 当运行 `make clean` 时，`make` 会执行与 `clean` 相关联的命令（在示例中是 `rm -f program main.o utils.o`），删除生成的中间文件和可执行文件，以便重新开始构建过程。
## 确切的过程是：
1. **正向读取**：
   - `make` 从 Makefile 文件的顶部开始，按照文件中定义的顺序读取每个目标及其依赖关系。
   - 它识别出主目标（例如 `all`）以及该目标所依赖的所有文件。
2. **反向执行**：
   - 对于每个目标，`make` 检查依赖项的时间戳，判断这些依赖文件是否需要更新；
   - 如果依赖文件比目标文件更新，或目标文件不存在，`make` 会反向查找并执行其依赖项的构建规则。这一过程递归进行，直到构建所有必要的文件。
3. **执行命令**：
   - 一旦所有依赖项都生成完成，`make` 将执行构建目标所需的命令（如链接命令）来生成最终的可执行文件。
# `clean` 不主动执行
在 Makefile 中，`clean` 目标通常是在所有构建目标执行完成后用于清理的。虽然 `clean` 目标在 Makefile 中是最后定义的（或与其他目标平行定义），但它的执行顺序是这样的：
1. **正常构建过程**：
   - 在执行 `make` 命令时，`make` 正向读取所有目标，执行依赖项的构建，生成最终的可执行文件。
2. **执行 clean**：
   - `clean` 目标本身不会在正常构建过程中执行，只有当您显式地运行 `make clean` 时，`make` 才会执行与 `clean` 相关联的命令。
   - 这通常用于删除所有生成的中间文件和最终的可执行文件，以便为下次构建提供一个干净的状态。
所以，尽管 `make` 读取 `clean` 目标时是按顺序进行的，它的执行实际上是在构建完成后进行的，确保了项目的清理。这种设计使得开发者可以在需要时快速清理项目，而不干扰正常的构建过程。
